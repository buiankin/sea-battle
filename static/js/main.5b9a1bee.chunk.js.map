{"version":3,"sources":["components/header.js","constants/index.js","constants/messages.js","components/board.js","components/my_board.js","components/opponent_board.js","utils/Common.js","utils/placeShip.js","utils/checkPlaceShip.js","utils/standardShipsSet.js","store.ts","App.tsx","reportWebVitals.ts","index.tsx"],"names":["Header","this","props","enemyTurn","respectfulAppeal","id","_titleText","React","Component","letters","Board","data","showHidden","grid","rows","_buildRowHeader","y","cells","className","x","push","_renderCell","value","key","classes","_cellId","_cellClasses","onClick","_handleCellClick","onDoubleClick","e","preventDefault","onMouseOver","_handleCellMouseOver","onMouseOut","_handleCellMouseOut","_cellValue","values","i","_boardClasses","_renderRows","MyBoard","_toggleCellClasses","selectedShip","classnames","pointer","cell","ship","Constants","ref","orientation","size","inbounds","overlapping","coords","OpponentBoard","onClickBoard","playerId","currentTurn","hit","getRandomInt","min","max","Math","ceil","floor","random","codeCoordinate","decodeCoordinate","s","result","s2","replace","toUpperCase","digits_alphabetical","length","toString","substring","includes","parseInt","field","direction","startSquare","containsShip","shipId","offsets","j","Ship","incrementId","hitpoints","latestId","placeVarious","enemyField","shot","isShipVisible","variableSet","l","checkPlaceShip","placeShip","getFullInitialState","boardInitialState","initial_myField","Array","myShips","initial_enemyField","enemyShips","val_in_line","enemy_val_in_line","forEach","ship0","my_grid","enemy_grid","remaining_hit_points","my_line","enemy_line","fieldVal","fieldVal_0","actionsToSend","my_board","myField","opponent_board","getBoardInitialState","character","enemyTurnForce","gameOver","youWin","emptyRow","emptyGrid","initialState","reducer","state","action","type","character_id","slice","coord","coord_str","newMyField","live_parts","playerLivesCount","Action","action_id","parameters","newEnemyField","Error","AppStyled","styled","div","body1","TypoScale","createGlobalStyle","sberBox","DocStyles","text","background","gradient","ThemeBackgroundEva","darkEva","ThemeBackgroundSber","darkSber","ThemeBackgroundJoy","darkJoy","App","memo","useReducer","appState","dispatch","assistantStateRef","useRef","assistantRef","_renderOpponentBoard","useEffect","getState","current","console","log","process","createAssistant","on","navigation","element","sendData","setTimeout","offsets4","primary_area","from","_","fill","live_ships","Set","add","_x","_y","primary_targets","targets","canFire","has","fire_coord","alphabetical_coord","processEnemyMove","message","_renderResult","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.5b9a1bee.chunk.js","sourcesContent":["import React, {Component} from 'react';\r\nimport PropTypes from 'prop-types'\r\n//import { setDocumentTitle }   from '../../utils';\r\n//import MyBoard from \"./my_board\";\r\n\r\nexport default class Header extends React.Component {\r\n\r\n  componentDidUpdate() {\r\n    //const { game } = this.props;\r\n    // TODO\r\n    //setDocumentTitle(`${this._titleText()} · #${game.id}`);\r\n  }\r\n\r\n  _titleText() {\r\n    //const { game, playerId, currentTurn, my_board, opponents_board } = this.props;\r\n    //const { readyForBattle } = game;\r\n    //let readyForBattle=true;\r\n    const { enemyTurn, respectfulAppeal } = this.props;\r\n\r\n    /*\r\n\r\n    if (!my_board.ready) {\r\n      return 'Place your ships';\r\n    } else if (!opponents_board || !opponents_board.ready) {\r\n      return 'Waiting for opponent';\r\n    } else if (currentTurn && currentTurn === playerId) {\r\n      return 'Your turn!';\r\n    } else if (currentTurn && currentTurn != playerId) {\r\n      return 'Your opponent\\'s turn!';\r\n    } else {\r\n      return 'Let the battle begin';\r\n    }\r\n     */\r\n    if (enemyTurn===true) {\r\n      return respectfulAppeal===false?'Ход твоего оппонента!':'Ход Вашего оппонента!';\r\n    } else {\r\n      return respectfulAppeal===false?'Твой ход!':'Ваш ход!';\r\n    }\r\n    \r\n  }\r\n\r\n  _messageText() {\r\n    const { enemyTurn, respectfulAppeal } = this.props;\r\n    /*\r\n    const { game, playerId, currentTurn } = this.props;\r\n    const { my_board, opponents_board, readyForBattle } = game;\r\n\r\n    if (!my_board.ready) {\r\n      return 'Use the instructions below';\r\n    } else if (!opponents_board || !opponents_board.ready) {\r\n      return 'Battle will start as soon as your opponent is ready';\r\n    } else if (currentTurn && currentTurn === playerId) {\r\n      return 'Click on your shooting grid to open fire!';\r\n    } else if (currentTurn && currentTurn != playerId) {\r\n      return 'Wait for your opponent to shoot...';\r\n    } else {\r\n      return 'Let the battle begin';\r\n    }\r\n     */\r\n    if (enemyTurn===true) {\r\n      return respectfulAppeal===false?'Ход твоего оппонента!':'Ход Вашего оппонента!';\r\n    } else {\r\n      return respectfulAppeal===false?'Твой ход!':'Ваш ход!';\r\n    }\r\n  }\r\n\r\n  render() {\r\n    return (\r\n      <header id=\"game_header\">\r\n        <h1>{this._titleText()}</h1>\r\n        {/*<p>{this._messageText()}</p>*/}\r\n      </header>\r\n    );\r\n  }\r\n}\r\n","export default {\n\n  // Session\n  SESSION_SET_PLAYER: 'SESSION_SET_PLAYER',\n\n  //  Home\n  HOME_NEW_GAME: 'HOME_NEW_GAME',\n  HOME_SET_CURRENT_GAMES: 'HOME_SET_CURRENT_GAMES',\n\n  // Game\n  GAME_SET_CHANNEL: 'GAME_SET_CHANNEL',\n  GAME_PLAYER_JOINED: 'GAME_PLAYER_JOINED',\n  GAME_PLAYER_LEFT: 'GAME_PLAYER_LEFT',\n  GAME_SET_GAME: 'GAME_SET_GAME',\n  GAME_ADD_MESSAGE: 'GAME_ADD_MESSAGE',\n  GAME_SETUP_SELECT_SHIP: 'GAME_SETUP_SELECT_SHIP',\n  GAME_OPPONENTS_BOARD_UPDATE: 'GAME_OPPONENTS_BOARD_UPDATE',\n  GAME_RESET: 'GAME_RESET',\n  GAME_OVER: 'GAME_OVER',\n  GAME_ERROR: 'GAME_ERROR',\n\n  //Ships\n  SHIP_ORIENTATION_HORIZONTAL: 'horizontal',\n  SHIP_ORIENTATION_VERTICAL: 'vertical',\n\n  // Boards\n  GRID_VALUE_WATER: '·',\n  GRID_VALUE_SHIP: '/',\n  GRID_VALUE_WATER_HIT: 'O',\n  GRID_VALUE_SHIP_HIT: '*',\n};\n","\r\nexport const letters = ['А', 'Б', 'В', 'Г', 'Д', 'Е', 'Ж', 'З', 'И', 'К'];\r\n\r\nexport const hello_messages = ['Привет!'];\r\nexport const hit_messages = ['Неплохо для слепого!'];\r\nexport const miss_messages = ['Мазила!', 'Мимо!', 'Промах!'];\r\nexport const kill_messages = ['Убил!'];\r\nexport const dont_understand = ['Моя твоя не понимай!'];\r\n\r\n","import React, {PropTypes} from 'react';\nimport classnames         from 'classnames';\nimport Constants from '../constants';\nimport {letters} from '../constants/messages';\n//import { setGame }        from '../../actions/game';\n\nexport default class Board extends React.Component {\n\n  constructor(props)\n  {\n    super(props);\n  }\n\n  _renderRows(data, showHidden) {\n\n    // showHidden важно только для opponent_board\n    const { grid } = data;\n\n    let rows = [this._buildRowHeader()];\n\n    for (let y = 0; y < 10; y++) {\n      let cells = [<div key={`header-${y}`} className=\"header cell\">{y + 1}</div>];\n\n      for (let x = 0; x < 10; x++) {\n        //cells.push(this._renderCell(y, x, grid[`${y}${x}`]));\n        // 15.02.2021 у нас это не строка 00, 01, 02 и т.д., а двухмерный массив\n        cells.push(this._renderCell(y, x, grid[y][x], showHidden));\n      }\n\n      rows.push(<div className=\"row\" key={y}>{cells}</div>);\n    }\n/*\n      let rows = [this._buildRowHeader()];\n\n      for (let y = 0; y < 10; y++) {\n          let cells = [<div key={`header-${y}`} className=\"header cell\">{y + 1}</div>];\n\n          for (let x = 0; x < 10; x++) {\n              cells.push(this._renderCell(y, x, '*'));\n          }\n\n          rows.push(<div className=\"row\" key={y}>{cells}</div>);\n      }\n*/\n\n\n    return rows;\n  }\n\n  _renderCell(y, x, value, showHidden) {\n    const key = `${y}${x}`;\n    const id = this._cellId(key);\n    const classes = this._cellClasses(value, showHidden);\n\n    return (\n      <div\n        id={this._cellId(key)}\n        className={classes}\n        key={key}\n        onClick={this._handleCellClick(y, x, value)}\n        onDoubleClick={(e) => e.preventDefault()}\n        onMouseOver={(y,x)=>this._handleCellMouseOver(y, x)}\n        onMouseOut={(y,x)=>this._handleCellMouseOut(y, x)}>{this._cellValue(value)}</div>\n    );\n  }\n\n  _buildRowHeader() {\n    let values = [<div key=\"empty\" className=\"header cell\"></div>];\n\n    for (var i = 0; i < 10; ++i) {\n      //  values.push(<div key={i} className=\"header cell\">{String.fromCharCode(i + 65)}</div>);\n      values.push(<div key={i} className=\"header cell\">{letters[i]}</div>);\n    }\n\n\n\n    return (\n      <div key=\"col-headers\" className=\"row\">\n        {values}\n      </div>\n    );\n  }\n\n  render() {\n      // 14.02.2012 TODO\n    const { data, showHidden } = this.props;\n    //if (!data) return false;\n\n    const classes = this._boardClasses();\n\n    return (\n      <div className={classes}>\n        {this._renderRows(data, showHidden)}\n      </div>\n    );\n  }\n}\n","import React, {PropTypes} from 'react';\nimport classnames         from 'classnames';\nimport Board              from './board';\nimport Constants          from '../constants';\n//import { setGame }        from '../../actions/game';\n//import { setError }       from '../../actions/game';\n\nexport default class MyBoard extends Board {\n\n    _handleCellClick(y, x, value) {\n    //const { selectedShip, gameChannel, dispatch } = this.props;\n    //const key = `${y}${x}`;\n\n    // 14.02.2021 Добавил\n    //const ready=true;\n    //\n\n    // Это было в actions\n    //  function setGame(game) {\n    //    return {\n    //      type: Constants.GAME_SET_GAME,\n    //      game: game,\n    //    };\n    //  }\n\n\n    return (e) => {\n      //if (selectedShip.id === null) return false;\n      if (value != Constants.GRID_VALUE_WATER) return false;\n\n      //const ship = {\n      //  x: x,\n      //  y: y,\n      //  size: selectedShip.size,\n      //  orientation: selectedShip.orientation,\n      //};\n\n      // TODO 08.02.2021\n      //gameChannel.push('game:place_ship', { ship: ship })\n      //.receive('ok', (payload) => dispatch(setGame(payload.game)));\n      //.receive('error', (payload) => dispatch(setError(payload.reason)));\n\n      return false;\n\n    };\n  }\n\n  _handleCellMouseOver(y, x) {\n    return this._toggleCellClasses(y, x);\n  }\n\n  _handleCellMouseOut(y, x) {\n    return this._toggleCellClasses(y, x);\n  }\n\n  _toggleCellClasses(y, x) {\n      // TODO это расстановка\n      /*\n    const { selectedShip } = this.props;\n\n    if (selectedShip.size === 0) return false;\n\n    const { size, orientation } = selectedShip;\n\n    const className = this._validCoords(y, x, orientation, size) ? 'ship-shape' : 'ship-shape-invalid';\n\n    return (e) => {\n      for (var i = 0; i < size; i++) {\n        const coords = orientation === 'horizontal' ? `${y}${x + i}` : `${y + i}${x}`;\n        let cell = document.getElementById(coords);\n        if (!cell) break;\n        cell.classList.toggle(className);\n      }\n    };\n       */\n  }\n\n  _cellValue(value) {\n    return false;\n  }\n\n  _boardClasses() {\n    const { selectedShip } = this.props;\n\n    return classnames({\n      grid: true,\n      pointer: selectedShip && selectedShip.id != null,\n    });\n  }\n\n  _cellClasses(value, showHidden) {\n    return classnames({\n      cell: true,\n      ship: value === Constants.GRID_VALUE_SHIP,\n      'ship-hit': value === Constants.GRID_VALUE_SHIP_HIT,\n      'water-hit': value === Constants.GRID_VALUE_WATER_HIT,\n    });\n  }\n\n  _cellId(ref) {\n    return ref;\n  }\n\n  _validCoords(y, x, orientation, size) {\n    const { data } = this.props;\n    let inbounds;\n\n    if (orientation === 'horizontal') {\n      inbounds = (x + size) <= 10;\n    } else {\n      inbounds = (y + size) <= 10;\n    }\n\n    let overlapping = false;\n\n    for (var i = 0; i < size; i++) {\n      const coords = orientation === 'horizontal' ? `${y}${x + i}` : `${y + i}${x}`;\n      if (data.grid[coords] != Constants.GRID_VALUE_WATER) {\n        overlapping = true;\n        break;\n      }\n    }\n\n    return inbounds && !overlapping;\n  }\n}\n","import React, {PropTypes} from 'react';\nimport classnames         from 'classnames';\nimport Board              from './board';\nimport Constants          from '../constants';\n//import { setGame }        from '../../actions/game';\n\nexport default class OpponentBoard extends Board {\n\n  constructor(props) {\n    super(props);\n\n  }\n\n  _handleCellClick(y, x, value) {\n    //const { gameChannel, currentTurn, playerId, dispatch } = this.props;\n\n    //if (currentTurn !== playerId) return false;\n\n    //const key = `${y}${x}`;\n\n    // Это было в actions\n    //function setGame(game) {\n    //  return {\n    //    type: Constants.GAME_SET_GAME,\n    //    game: game,\n    //  };\n    //}\n\n    return (e) => { \n      this.props.onClickBoard(x, y);\n    }\n\n\n    //return (e) => {\n    //  if (value != Constants.GRID_VALUE_WATER) return false;\n\n      //gameChannel.push('game:shoot', { y: y, x: x })\n      //.receive('ok', (payload) => {\n      //  dispatch(setGame(payload.game));\n      //})\n      //.receive('error', (payload) => console.log(payload));\n\n\n    //};\n  }\n\n  _handleCellMouseOver(y, x) {\n    return false;\n  }\n\n  _cellValue(value) {\n    return '';\n  }\n\n  _boardClasses() {\n    const { playerId, currentTurn } = this.props;\n\n    return classnames({\n      grid: true,\n      pointer: playerId === currentTurn,\n    });\n  }\n\n  _cellClasses(value, showHidden) {\n    return classnames({\n      cell: true,\n      // TODO только во время отладки\n      ship: showHidden && value === Constants.GRID_VALUE_SHIP,\n      //\n      hit: value === Constants.GRID_VALUE_SHIP_HIT,\n      'water-hit': value === Constants.GRID_VALUE_WATER_HIT,\n    });\n  }\n\n  _cellId(ref) {\n    return false;\n  }\n\n  _handleCellMouseOut(e) {\n    return false;\n  }\n}\n","\r\nimport { letters } from '../constants/messages';\r\n\r\n\r\nexport function getRandomArbitrary(min, max) {\r\n    return Math.random() * (max - min) + min;\r\n}\r\n\r\nexport function getRandomInt(min, max) {\r\n    min = Math.ceil(min);\r\n    max = Math.floor(max);\r\n    return Math.floor(Math.random() * (max - min + 1)) + min;\r\n}\r\n\r\nexport function codeCoordinate(x, y)\r\n{\r\n  return letters[x]+(y+1);\r\n}\r\n\r\n\r\nexport function decodeCoordinate(s)\r\n{\r\n  let result=null;\r\n  let y=-1;\r\n  // И сразу добавим пробелы по краям, чтобы можно было найти числа, произнесенные голосом\r\n  let s2=s.replace(\"-\", \" \").toUpperCase();\r\n  const digits_alphabetical=['ОДИН', 'ДВА', 'ТРИ', 'ЧЕТЫРЕ', 'ПЯТЬ', 'ШЕСТЬ', 'СЕМЬ', 'ВОСЕМЬ', 'ДЕВЯТЬ', 'ДЕСЯТЬ'];\r\n  for (let i=0; i<digits_alphabetical.length; i++)\r\n  {\r\n    s2=s2.replace(digits_alphabetical[i], (i+1).toString());\r\n  }\r\n  s2=s2.replace(\" \", \"\");\r\n  if (s2.length===3&&s2.substring(1)===\"10\")\r\n  {\r\n    y=9;\r\n  } else if (s2.length===2) {\r\n    if ('0123456789'.includes(s2.substring(2)))\r\n      y=parseInt(s2.substring(1))-1;\r\n  }\r\n  switch (s2.substring(0,1))\r\n  {\r\n    case 'А':\r\n      result={x:0, y:y};\r\n      break;\r\n    case 'Б':\r\n      result={x:1, y:y};\r\n      break;\r\n    case 'В':\r\n      result={x:2, y:y};\r\n      break;\r\n    case 'Г':\r\n      result={x:3, y:y};\r\n      break;\r\n    case 'Д':\r\n      result={x:4, y:y};\r\n      break;\r\n    case 'Е':\r\n      result={x:5, y:y};\r\n      break;\r\n    case 'Ж':\r\n      result={x:6, y:y};\r\n      break;\r\n    case 'З':\r\n      result={x:7, y:y};\r\n      break;\r\n    case 'И':\r\n      result={x:8, y:y};\r\n      break;\r\n    case 'К':\r\n      result={x:9, y:y};\r\n      break;\r\n                                                                \r\n  }\r\n  return result;\r\n}","// небольшая функция-сниппет, которая добавляет корабль на поле\n// сдвиг на единицу появился из-за отсчета индекса массива с нуля\n\nexport default (field, ship) => {\n    switch(ship.direction) {\n        case 'right': \n        for (let i = ship.startSquare.x - 1; i < ship.startSquare.x - 1 + ship.size; i++) {\n            field[ship.startSquare.y - 1][i].containsShip = true;\n            field[ship.startSquare.y - 1][i].shipId = ship.id;\n        }\n        break;\n        case 'down': \n        for (let i = ship.startSquare.y - 1; i < ship.startSquare.y - 1 + ship.size; i++) {\n            field[i][ship.startSquare.x - 1].containsShip = true;\n            field[i][ship.startSquare.x - 1].shipId = ship.id;\n        }\n        break;\n        default:\n    }\n}\n","\nexport default (field, ship) => {\n    const offsets=[{x:-1,y:-1}, {x:0,y:-1}, {x:1,y:-1},\n        {x:-1,y:0}, {x:0,y:0}, {x:1,y:0},\n        {x:-1,y:1}, {x:0,y:1}, {x:1,y:1},\n    ];\n    switch(ship.direction) {\n        case 'right':\n            for (let i = ship.startSquare.x - 1; i < ship.startSquare.x - 1 + ship.size; i++) {\n                //field[ship.startSquare.y - 1][i].containsShip = true;\n                //field[ship.startSquare.y - 1][i].shipId = ship.id;\n                for (let j=0; j<offsets.length; j++)\n                {\n                    let y=offsets[j].y+ship.startSquare.y - 1;\n                    let x=offsets[j].x+i;\n                    if (x<0||y<0||x>=10|y>=10)\n                    {\n                        // корабль находится в углу поля, там других кораблей нет\n                    } else {\n                        if (field[y][x].containsShip)\n                            return false;\n                    }\n                }\n\n            }\n            break;\n        case 'down':\n            for (let i = ship.startSquare.y - 1; i < ship.startSquare.y - 1 + ship.size; i++) {\n                //field[i][ship.startSquare.x - 1].containsShip = true;\n                //field[i][ship.startSquare.x - 1].shipId = ship.id;\n                for (let j=0; j<offsets.length; j++)\n                {\n                    let y=offsets[j].y+i;\n                    let x=offsets[j].x+ship.startSquare.x - 1;\n                    if (x<0||y<0||x>=10|y>=10)\n                    {\n                        // корабль находится в углу поля, там других кораблей нет\n                    } else {\n                        if (field[y][x].containsShip)\n                            return false;\n                    }\n                }\n\n            }\n            break;\n        default:\n    }\n    return true;\n}","// компонент, который создает и экспортирует стандартный набор кораблей\r\n// направление кораблю задается для того, чтобы можно было определить, в какую сторону его рисовать из стартовой точки\r\n// Размещать корабли можно либо вертикально, либо горизонтально, были выбраны направления вправо(right) и вниз(down), \r\n// поскольку они совпадают с положительными направлениеми координатных осей\r\n\r\nimport {getRandomInt} from './Common'\r\nimport placeShip from \"./placeShip\";\r\nimport checkPlaceShip from \"./checkPlaceShip\";\r\n\r\nclass Ship {\r\n    constructor(size, startSquare, direction) {\r\n        this.size = size;\r\n        this.startSquare = startSquare;\r\n        this.direction = direction;\r\n        this.id = Ship.incrementId();\r\n        this.hitpoints = this.size;\r\n    }\r\n\r\n    static incrementId() {\r\n        if (!this.latestId) {\r\n            this.latestId = 1;\r\n        } else {\r\n            this.latestId++;\r\n        }\r\n        return this.latestId\r\n    }\r\n}\r\n\r\n\r\nexport function placeVarious()\r\n{\r\n    let enemyField = [];\r\n\r\n    // первоначальное (пустое) состояние поля\r\n    for (let i = 0; i < 10; i++) {\r\n        enemyField.push([]);\r\n    }\r\n\r\n    for (let i = 0; i < 10; i++) {\r\n        for (let j = 0; j < 10; j++) {\r\n            enemyField[i].push({\r\n                x: j,\r\n                y: i,\r\n                containsShip: false,\r\n                shot: false,\r\n                isShipVisible: false,\r\n                shipId: null,\r\n            });\r\n        }\r\n    }\r\n\r\n\r\n    let variableSet = [];\r\n    // i-порядок расстановки (оно же количество короблей такой длины)\r\n    // и соответственно длина на каждом уровне  5-i\r\n    for (let i=1; i<=4; i++)\r\n    //for (let i=1; i<=1; i++)\r\n    {\r\n        for (let j=1; j<=i; j++)\r\n        {\r\n            // длина корабля\r\n            let l=5-i;\r\n            let ship, x, y;\r\n            for(;;) {\r\n                x = getRandomInt(1, 10 - l + 1);\r\n                y = getRandomInt(1, 10);\r\n\r\n                let direction=Math.random();\r\n                if (direction>= 0.5) {\r\n                    ship = new Ship(l, {y: y, x: x}, 'right');\r\n                } else {\r\n                    ship = new Ship(l, {y: x, x: y}, 'down');\r\n                }\r\n                if (checkPlaceShip(enemyField, ship))\r\n                   break;\r\n            }\r\n            placeShip(enemyField, ship);\r\n            variableSet.push(ship);\r\n        }\r\n\r\n    }\r\n    return variableSet;\r\n}\r\n\r\nexport default placeVarious;","import Constants from './constants';\r\nimport { codeCoordinate, decodeCoordinate} from './utils/Common';\r\n\r\nimport MyBoard from './components/my_board'\r\nimport OpponentBoard from './components/opponent_board';\r\n\r\nimport placeShip from './utils/placeShip';\r\nimport placeVarious from './utils/standardShipsSet';\r\n\r\nfunction getBoardInitialState()\r\n{\r\n  let initial_myField = Array(0);\r\n  let myShips = placeVarious();\r\n\r\n  let initial_enemyField = Array(0);\r\n  let enemyShips = placeVarious();\r\n\r\n\r\n  // первоначальное (пустое) состояние поля\r\n  //for (let i = 0; i < 10; i++) {\r\n  //  initial_myField.push([]);\r\n  //  initial_enemyField.push([]);\r\n  //}\r\n\r\n  for (let i = 0; i < 10; i++) {\r\n    let val_in_line = [];\r\n    let enemy_val_in_line = [];\r\n\r\n    for (let j = 0; j < 10; j++) {\r\n      val_in_line.push({\r\n        x: j,\r\n        y: i,\r\n        containsShip: false,\r\n        shot: false,\r\n        isShipVisible: false,\r\n        shipId: null,\r\n      });\r\n\r\n      enemy_val_in_line.push({\r\n        x: j,\r\n        y: i,\r\n        containsShip: false,\r\n        shot: false,\r\n        isShipVisible: false,\r\n        shipId: null,\r\n      });\r\n    }\r\n\r\n    initial_myField.push(val_in_line);\r\n    initial_enemyField.push(enemy_val_in_line);\r\n  }\r\n\r\n    // расставляем стандартный набор кораблей\r\n    myShips.forEach((ship: any) => {\r\n      placeShip(initial_myField, ship)\r\n    });\r\n    enemyShips.forEach((ship0: any) => {\r\n      placeShip(initial_enemyField, ship0)\r\n    });\r\n\r\n\r\n  let my_grid = [];\r\n  let enemy_grid = [];\r\n\r\n  // Заполняем из наших массивов\r\n  let remaining_hit_points = 0;\r\n  for (let y = 0; y < 10; y++) {\r\n    let my_line = [];\r\n    let enemy_line = [];\r\n    for (let x = 0; x < 10; x++) {\r\n      // Наши корабли\r\n      let fieldVal = initial_myField[y][x];\r\n      let fieldVal_0 = fieldVal.shot ? Constants.GRID_VALUE_WATER_HIT : Constants.GRID_VALUE_WATER;\r\n      if (fieldVal.containsShip)\r\n        fieldVal_0 = fieldVal.shot ? Constants.GRID_VALUE_SHIP_HIT : Constants.GRID_VALUE_SHIP;\r\n      my_line.push(fieldVal_0);\r\n      // Корабли оппонента\r\n      fieldVal = initial_enemyField[y][x];\r\n      fieldVal_0 = fieldVal.shot ? Constants.GRID_VALUE_WATER_HIT : Constants.GRID_VALUE_WATER;\r\n      if (fieldVal.containsShip) {\r\n        fieldVal_0 = fieldVal.shot ? Constants.GRID_VALUE_SHIP_HIT : Constants.GRID_VALUE_SHIP;\r\n        remaining_hit_points++;\r\n      }\r\n      enemy_line.push(fieldVal_0);\r\n    }\r\n\r\n    my_grid.push(my_line);\r\n    enemy_grid.push(enemy_line);\r\n\r\n  }\r\n\r\n  let initial_my_board = { grid: my_grid };\r\n  let initial_opponent_board = { grid: enemy_grid, remaining_hit_points};\r\n\r\n  return {\r\n    //notes: [],\r\n    actionsToSend: [],\r\n\r\n    my_board: initial_my_board,\r\n    myField: initial_myField,\r\n    opponent_board: initial_opponent_board,\r\n    enemyField: initial_enemyField\r\n  };\r\n\r\n}\r\n\r\nfunction getFullInitialState()\r\n{\r\n  let boardInitialState=getBoardInitialState();\r\n  let state={\r\n    actionsToSend: [],\r\n    my_board: boardInitialState.my_board,\r\n    myField: boardInitialState.myField,\r\n    opponent_board: boardInitialState.opponent_board,\r\n    enemyField: boardInitialState.enemyField,\r\n    character: 'sber',\r\n    respectfulAppeal: true, \r\n    enemyTurnForce: 0,\r\n    enemyTurn: false, gameOver: false, youWin: false,\r\n    // TODO false\r\n    showHidden: true\r\n  };\r\n  return state;\r\n}\r\n\r\n\r\nconst emptyRow=[Constants.GRID_VALUE_WATER, Constants.GRID_VALUE_WATER, Constants.GRID_VALUE_WATER, Constants.GRID_VALUE_WATER, Constants.GRID_VALUE_WATER,\r\n  Constants.GRID_VALUE_WATER, Constants.GRID_VALUE_WATER, Constants.GRID_VALUE_WATER, Constants.GRID_VALUE_WATER, Constants.GRID_VALUE_WATER];\r\nconst emptyGrid=[emptyRow,emptyRow,emptyRow,emptyRow,emptyRow,emptyRow,emptyRow,emptyRow,emptyRow,emptyRow];\r\n\r\n// важно - тот же самый тип должен быть у getFullInitialState()\r\nexport const initialState = { actionsToSend: [], my_board: {grid: emptyGrid}, myField: [], opponent_board: {grid: emptyGrid, remaining_hit_points:0}, enemyField: [],\r\n  character: 'sber',\r\n  respectfulAppeal: true, \r\n  enemyTurnForce: 0,\r\n  enemyTurn: false, gameOver: false, youWin: false,\r\n  showHidden: false\r\n};\r\n\r\n\r\n/*\r\ntype Note = {\r\n  id: string;\r\n  title: string;\r\n  completed: boolean;\r\n};\r\n*/\r\n\r\ntype ActionToSend = {\r\n  id: string;\r\n  Action: { action: any };\r\n}\r\n\r\ntype State = {\r\n  //notes: Array<Note>;\r\n  actionsToSend: Array<ActionToSend>,\r\n\r\n  my_board: { grid: string[][]},\r\n  myField: any[],\r\n  opponent_board: { grid: string[][], remaining_hit_points: number},\r\n  enemyField: any[],\r\n\r\n  character: string,\r\n  respectfulAppeal: boolean, \r\n  enemyTurnForce: number, enemyTurn: boolean, gameOver: boolean, youWin: boolean,\r\n  showHidden: boolean\r\n};\r\n\r\ntype Action =\r\n  | {\r\n    type: \"init\";\r\n  }\r\n  | {\r\n    type: \"show_ships\";\r\n  }\r\n  | {\r\n    type: \"character\";\r\n    character_id: string;\r\n    }\r\n  | {\r\n    type: \"game_over_lost\";\r\n    }\r\n  | {\r\n    type: \"game_replay\";\r\n    }\r\n  | {\r\n    type: \"clear_action\";\r\n    id: string;\r\n    }\r\n  | {\r\n    type: \"enemy_fire\";\r\n    coord_str: string;\r\n  }\r\n  | {\r\n    type: \"lets_fire\";\r\n    coord_str: string;\r\n  };\r\n\r\n  /*\r\n  | {\r\n      type: \"add_note\";\r\n      note: string;\r\n    }\r\n  | {\r\n      type: \"done_note\";\r\n      id: string;\r\n    }\r\n  | {\r\n      type: \"delete_note\";\r\n      id: string;\r\n    };\r\n    */\r\n\r\nexport const reducer = (state: State, action: Action) => {\r\n\r\n  switch (action.type) {\r\n      /*\r\n    case \"init\":\r\n      let initial_myField = Array(0);\r\n      let myShips = placeVarious();\r\n    \r\n      let initial_enemyField = Array(0);\r\n      let enemyShips = placeVarious();\r\n    \r\n    \r\n      // первоначальное (пустое) состояние поля\r\n      //for (let i = 0; i < 10; i++) {\r\n      //  initial_myField.push([]);\r\n      //  initial_enemyField.push([]);\r\n      //}\r\n    \r\n      for (let i = 0; i < 10; i++) {\r\n        let val_in_line = [];\r\n        let enemy_val_in_line = [];\r\n    \r\n        for (let j = 0; j < 10; j++) {\r\n          val_in_line.push({\r\n            x: j,\r\n            y: i,\r\n            containsShip: false,\r\n            shot: false,\r\n            isShipVisible: false,\r\n            shipId: null,\r\n          });\r\n    \r\n          enemy_val_in_line.push({\r\n            x: j,\r\n            y: i,\r\n            containsShip: false,\r\n            shot: false,\r\n            isShipVisible: false,\r\n            shipId: null,\r\n          });\r\n        }\r\n    \r\n        initial_myField.push(val_in_line);\r\n        initial_enemyField.push(enemy_val_in_line);\r\n      }\r\n    \r\n        // расставляем стандартный набор кораблей\r\n        myShips.forEach((ship: any) => {\r\n          placeShip(initial_myField, ship)\r\n        });\r\n        enemyShips.forEach((ship0: any) => {\r\n          placeShip(initial_enemyField, ship0)\r\n        });\r\n    \r\n    \r\n      let my_grid = [];\r\n      let enemy_grid = [];\r\n    \r\n      // Заполняем из наших массивов\r\n      let remaining_hit_points = 0;\r\n      for (let y = 0; y < 10; y++) {\r\n        let my_line = [];\r\n        let enemy_line = [];\r\n        for (let x = 0; x < 10; x++) {\r\n          // Наши корабли\r\n          let fieldVal = initial_myField[y][x];\r\n          let fieldVal_0 = fieldVal.shot ? Constants.GRID_VALUE_WATER_HIT : Constants.GRID_VALUE_WATER;\r\n          if (fieldVal.containsShip)\r\n            fieldVal_0 = fieldVal.shot ? Constants.GRID_VALUE_SHIP_HIT : Constants.GRID_VALUE_SHIP;\r\n          my_line.push(fieldVal_0);\r\n          // Корабли оппонента\r\n          fieldVal = initial_enemyField[y][x];\r\n          fieldVal_0 = fieldVal.shot ? Constants.GRID_VALUE_WATER_HIT : Constants.GRID_VALUE_WATER;\r\n          if (fieldVal.containsShip) {\r\n            fieldVal_0 = fieldVal.shot ? Constants.GRID_VALUE_SHIP_HIT : Constants.GRID_VALUE_SHIP;\r\n            remaining_hit_points++;\r\n          }\r\n          enemy_line.push(fieldVal_0);\r\n        }\r\n    \r\n        my_grid.push(my_line);\r\n        enemy_grid.push(enemy_line);\r\n    \r\n      }\r\n    \r\n      let initial_my_board = { grid: my_grid };\r\n      let initial_opponent_board = { grid: enemy_grid, remaining_hit_points};\r\n    \r\n      return {\r\n        notes: [],\r\n        my_board: initial_my_board,\r\n        myField: initial_myField,\r\n        opponent_board: initial_opponent_board,\r\n        enemyField: initial_enemyField\r\n      };\r\n      */\r\n\r\n    case \"init\":\r\n      return getFullInitialState();\r\n\r\n\r\n    case \"character\":\r\n      return {\r\n        ...state,\r\n        character: action.character_id, respectfulAppeal: action.character_id!=='joy'\r\n      }\r\n  \r\n    case \"show_ships\":\r\n      return {\r\n        ...state,\r\n        showHidden: true\r\n      }\r\n\r\n    case \"game_over_lost\":\r\n      return {\r\n        ...state,\r\n        gameOver: true, youWin: false\r\n      }\r\n\r\n    case \"game_replay\":\r\n      return {\r\n        ...getFullInitialState(),\r\n        character: state.character,\r\n        respectfulAppeal: state.respectfulAppeal\r\n      }\r\n\r\n    case \"clear_action\":\r\n      return {\r\n        ...state,\r\n        actionsToSend: []\r\n      }\r\n\r\n    case \"enemy_fire\":\r\n    {\r\n      let actionsToSend=state.actionsToSend.slice();\r\n\r\n      let fire_registered=false;\r\n      let coord=decodeCoordinate(action.coord_str);\r\n      if (coord)\r\n      {\r\n        let x=coord.x, y=coord.y;\r\n\r\n        let field=state.myField[y][x];\r\n        if (field.containsShip)\r\n        {\r\n          // Попали в корабль\r\n          if (!field.shot)\r\n          {\r\n            // До этого в это поле не попадали\r\n            fire_registered=true;\r\n            let newMyField=state.myField.slice();\r\n            newMyField[y]=newMyField[y].slice();\r\n            newMyField[y][x]={...newMyField[y][x], shot:true};\r\n            let shipId=field.shipId;\r\n            // Проверим, есть ли еще не подбитые его части\r\n            let live_parts=0;\r\n            for (let y = 0; y < 10; y++) {\r\n              for (let x = 0; x < 10; x++) {\r\n                if (newMyField[y][x].containsShip && newMyField[y][x].shipId===shipId)\r\n                {\r\n                  if (!newMyField[y][x].shot)\r\n                    live_parts++;\r\n                }\r\n              }\r\n            }\r\n            // TODO если корабль полностью подбит, рисовать его как-то по-другому\r\n        \r\n            let grid=state.my_board.grid.slice();\r\n            grid[y]=state.my_board.grid[y].slice();\r\n            grid[y][x] = Constants.GRID_VALUE_SHIP_HIT;\r\n            /*\r\n            if (live_parts>0)\r\n              actionsToSend.push({id:'0', Action: { action: { action_id: 'fireHit', parameters: { coord: action.coord_str} } }});\r\n            else\r\n              actionsToSend.push({id:'0', Action: { action: { action_id: 'fireDone', parameters: { coord: action.coord_str} } }});\r\n            */\r\n\r\n            // посчитаем, сколько у игрока осталось кораблей\r\n            let playerLivesCount=0;\r\n            for (let y = 0; y < 10; y++) {\r\n              for (let x = 0; x < 10; x++) {\r\n                // если туда еще не стреляли\r\n                if (!newMyField[y][x].shot&&newMyField[y][x].containsShip)\r\n                  playerLivesCount++;\r\n              }\r\n            }\r\n           \r\n            if (playerLivesCount>0)\r\n            {\r\n              // TODO еще один выстрел\r\n            //  setTimeout(() => processEnemyMove(), 1200);\r\n\r\n              // просто очередное попадание, ход не переходит\r\n              return {...state,\r\n                my_board: {grid: grid},\r\n                myField: newMyField,\r\n                actionsToSend: actionsToSend,\r\n                // а это сделано для того, чтобы вызвалась проверка enemyTurn\r\n                enemyTurnForce: state.enemyTurnForce+1\r\n                }\r\n  \r\n            } else\r\n            {\r\n              // Игра окончена\r\n              //setAppState({...appState, gameOver: true, youWin: false});\r\n              actionsToSend.push({id:'0', Action: { action: { action_id: 'gameOverLost', parameters: {} } }});\r\n              // игрок выиграл\r\n              return {...state,\r\n                my_board: {grid: grid},\r\n                myField: newMyField,\r\n                gameOver: true,\r\n                youWin: false,\r\n                actionsToSend: actionsToSend\r\n                }\r\n            }\r\n\r\n          } else {\r\n            // Повторное попадание. Ход считаем, что не переходит\r\n            //actionsToSend.push({id:'0', Action: { action: { action_id: 'fireAgain', parameters: { coord: action.coord_str} } }});\r\n          }\r\n        } else {\r\n          // Попали в воду\r\n          let grid=state.my_board.grid.slice();\r\n          grid[y]=state.my_board.grid[y].slice();\r\n          if (grid[y][x] === Constants.GRID_VALUE_WATER)\r\n          {\r\n            // До этого туда не стреляли\r\n            fire_registered=true;\r\n            // хотя это бы и не обязательно делать (заполнять enemyField для воды), все равно попадание у нас контролируется по-другому,\r\n            // но для корректности данных лучше так сделать\r\n            let newMyField=state.myField.slice();\r\n            newMyField[y]=newMyField[y].slice();\r\n            newMyField[y][x]={...newMyField[y][x], shot:true};\r\n            //\r\n            grid[y][x] = Constants.GRID_VALUE_WATER_HIT;\r\n            //this.setState({ enemyField: newEnemyField, opponent_board: { ...this.state.opponent_board, grid: grid} });\r\n            return {...state,\r\n              my_board: { ...state.my_board, grid: grid}, myField: newMyField,\r\n              enemyTurn: false\r\n            }\r\n          }\r\n          //actionsToSend.push({id:'0', Action: { action: { action_id: 'fireMiss', parameters: { coord: action.coord_str} } }});\r\n        }\r\n      }\r\n  \r\n      return {\r\n        ...state\r\n      }\r\n    }\r\n\r\n    case \"lets_fire\":\r\n    {\r\n      let actionsToSend=state.actionsToSend.slice();\r\n      if (state.enemyTurn)\r\n      {\r\n        // тут про сессии можно почитать\r\n        // https://developer.sberdevices.ru/docs/ru/developer_tools/ide/JS_API/session_lifetime_control\r\n        actionsToSend.push({id:'0', Action: { action: { action_id: 'myMove'} }});\r\n        // и на всякий случай защита от зависания таймера\r\n        return {\r\n          ...state,\r\n          actionsToSend: actionsToSend,\r\n          enemyTurnForce: state.enemyTurnForce+1\r\n        }\r\n        \r\n      } else\r\n      {\r\n        //alert(myAction.coord_str);\r\n        let fire_registered=false;\r\n        let coord=decodeCoordinate(action.coord_str);\r\n        if (coord)\r\n        {\r\n          let x=coord.x, y=coord.y;\r\n  \r\n          let field=state.enemyField[y][x];\r\n          if (field.containsShip)\r\n          {\r\n            // Попали в корабль\r\n            if (!field.shot)\r\n            {\r\n              // До этого в это поле не попадали\r\n              fire_registered=true;\r\n              let newEnemyField=state.enemyField.slice();\r\n              newEnemyField[y]=newEnemyField[y].slice();\r\n              newEnemyField[y][x]={...newEnemyField[y][x], shot:true};\r\n              let shipId=field.shipId;\r\n              // Проверим, есть ли еще не подбитые его части\r\n              let live_parts=0;\r\n              for (let y = 0; y < 10; y++) {\r\n                for (let x = 0; x < 10; x++) {\r\n                  if (newEnemyField[y][x].containsShip && newEnemyField[y][x].shipId===shipId)\r\n                  {\r\n                    if (!newEnemyField[y][x].shot)\r\n                      live_parts++;\r\n                  }\r\n                }\r\n              }\r\n              // TODO если корабль полностью подбит, рисовать его как-то по-другому\r\n          \r\n              let grid=state.opponent_board.grid.slice();\r\n              grid[y]=state.opponent_board.grid[y].slice();\r\n              grid[y][x] = Constants.GRID_VALUE_SHIP_HIT;\r\n              if (live_parts>0)\r\n                actionsToSend.push({id:'0', Action: { action: { action_id: 'fireHit', parameters: { coord: action.coord_str} } }});\r\n              else\r\n                actionsToSend.push({id:'0', Action: { action: { action_id: 'fireDone', parameters: { coord: action.coord_str} } }});\r\n              if (state.opponent_board.remaining_hit_points<=1)\r\n              {\r\n                actionsToSend.push({id:'0', Action: { action: { action_id: 'gameOverWin', parameters: {} } }});\r\n                // игрок выиграл\r\n                return {...state,\r\n                  opponent_board: {grid: grid, remaining_hit_points: state.opponent_board.remaining_hit_points-1},\r\n                  enemyField: newEnemyField,\r\n                  gameOver: true,\r\n                  youWin: true,\r\n                  actionsToSend: actionsToSend\r\n                  }\r\n              } else {\r\n                // просто очередное попадание, ход не переходит\r\n                return {...state,\r\n                opponent_board: {grid: grid, remaining_hit_points: state.opponent_board.remaining_hit_points-1},\r\n                enemyField: newEnemyField,\r\n                actionsToSend: actionsToSend\r\n                }\r\n              }\r\n  \r\n            } else {\r\n              // Повторное попадание. Ход считаем, что не переходит\r\n              actionsToSend.push({id:'0', Action: { action: { action_id: 'fireAgain', parameters: { coord: action.coord_str} } }});\r\n            }\r\n          } else {\r\n            // Попали в воду\r\n            let grid=state.opponent_board.grid.slice();\r\n            grid[y]=state.opponent_board.grid[y].slice();\r\n            if (grid[y][x] === Constants.GRID_VALUE_WATER)\r\n            {\r\n              // До этого туда не стреляли\r\n              fire_registered=true;\r\n              // хотя это бы и не обязательно делать (заполнять enemyField для воды), все равно попадание у нас контролируется по-другому,\r\n              // но для корректности данных лучше так сделать\r\n              let newEnemyField=state.enemyField.slice();\r\n              newEnemyField[y]=newEnemyField[y].slice();\r\n              newEnemyField[y][x]={...newEnemyField[y][x], shot:true};\r\n              //\r\n              grid[y][x] = Constants.GRID_VALUE_WATER_HIT;\r\n              //this.setState({ enemyField: newEnemyField, opponent_board: { ...this.state.opponent_board, grid: grid} });\r\n              actionsToSend.push({id:'0', Action: { action: { action_id: 'fireMiss', parameters: { coord: action.coord_str} } }});\r\n\r\n              return {...state,\r\n                opponent_board: { ...state.opponent_board, grid: grid}, enemyField: newEnemyField,\r\n                enemyTurn: true\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n      return {\r\n        ...state,\r\n        actionsToSend: actionsToSend\r\n      }\r\n    }\r\n      \r\n  \r\n\r\n      /*\r\n      let fire_registered=false;\r\n      let coord=decodeCoordinate(action.coord_str);\r\n      if (coord)\r\n      {\r\n        let x=coord.x, y=coord.y;\r\n\r\n        let field=state.enemyField[y][x];\r\n        if (field.containsShip)\r\n        {\r\n          // Попали в корабль\r\n          if (!field.shot)\r\n          {\r\n            // До этого в это поле не попадали\r\n            fire_registered=true;\r\n            let newEnemyField=state.enemyField.slice();\r\n            newEnemyField[y][x].shot=true;\r\n            let shipId=field.shipId;\r\n            // Проверим, есть ли еще не подбитые его части\r\n            let live_parts=0;\r\n            for (let y = 0; y < 10; y++) {\r\n              for (let x = 0; x < 10; x++) {\r\n                if (newEnemyField[y][x].containsShip && newEnemyField[y][x].shipId===shipId)\r\n                {\r\n                  if (!newEnemyField[y][x].shot)\r\n                    live_parts++;\r\n                }\r\n              }\r\n            }\r\n            // TODO если корабль полностью подбит, рисовать его как-то по-другому\r\n        \r\n            let grid=state.opponent_board.grid.slice();\r\n            grid[y][x] = Constants.GRID_VALUE_SHIP_HIT;\r\n            //setState({ enemyField: newEnemyField, opponent_board: { ...appState.opponent_board, grid: grid, remaining_hit_points: remaining_hit_points} });\r\n            let newState={...state,\r\n            opponent_board: {grid: grid, remaining_hit_points: state.opponent_board.remaining_hit_points-1},\r\n            enemyField: newEnemyField\r\n            };\r\n            return newState;\r\n          } else {\r\n            // Повторное попадание\r\n          }\r\n        } else {\r\n          // Попали в воду\r\n          let grid=state.opponent_board.grid.slice();\r\n          if (grid[y][x] === Constants.GRID_VALUE_WATER)\r\n          {\r\n            // До этого туда не стреляли\r\n            fire_registered=true;\r\n            // хотя это бы и не обязательно делать (заполнять enemyField для воды), все равно попадание у нас контролируется по-другому,\r\n            // но для корректности данных лучше так сделать\r\n            let newEnemyField=state.enemyField.slice();\r\n            newEnemyField[y][x].shot=true;\r\n            //\r\n            grid[y][x] = Constants.GRID_VALUE_WATER_HIT;\r\n            //this.setState({ enemyField: newEnemyField, opponent_board: { ...this.state.opponent_board, grid: grid} });\r\n            return {\r\n              ...state,\r\n              opponent_board: { ...state.opponent_board, grid: grid}, enemyField: newEnemyField\r\n            };\r\n      \r\n          }\r\n        }\r\n      }\r\n      return {\r\n        ...state,     \r\n      }\r\n      */\r\n      \r\n/* \r\n      let grid=state.opponent_board.grid.slice();\r\n      grid[0][0] = Constants.GRID_VALUE_SHIP_HIT;\r\n      let remaining_hit_points = state.opponent_board.remaining_hit_points;\r\n      remaining_hit_points = remaining_hit_points - 1;\r\n      return {\r\n        ...state,\r\n        opponent_board: { grid: grid, remaining_hit_points: remaining_hit_points }\r\n      };\r\n     case \"add_note\":\r\n      return {\r\n        ...state,\r\n        notes: [\r\n          ...state.notes,\r\n          {\r\n            id: Math.random().toString(36).substring(7),\r\n            title: action.note,\r\n            completed: false,\r\n          },\r\n        ],\r\n      };\r\n\r\n    case \"done_note\":\r\n      return {\r\n        ...state,\r\n        notes: state.notes.map((note) =>\r\n          note.id === action.id ? { ...note, completed: !note.completed } : note\r\n        ),\r\n      };\r\n\r\n    case \"delete_note\":\r\n      return {\r\n        ...state,\r\n        notes: state.notes.filter(({ id }) => id !== action.id),\r\n      };\r\n      */\r\n\r\n    default:\r\n      throw new Error();\r\n  }\r\n};\r\n","import React, {\r\n  FC,\r\n  memo,\r\n  useReducer,\r\n  useState,\r\n  useRef,\r\n  useEffect,\r\n  useLayoutEffect,\r\n  RefObject,\r\n} from 'react';\r\n\r\nimport {\r\n  createSmartappDebugger,\r\n  createAssistant,\r\n  AssistantAppState,\r\n  AssistantSmartAppData,\r\n  AssistantCharacterType\r\n} from \"@sberdevices/assistant-client\";\r\n\r\n//import  {Link} from 'react-router-dom';\r\n\r\nimport Constants from './constants';\r\nimport Header from './components/header'\r\nimport Chat from './components/chat'\r\nimport MyBoard from './components/my_board'\r\nimport OpponentBoard from './components/opponent_board';\r\n\r\nimport placeShip from './utils/placeShip';\r\nimport placeVarious from './utils/standardShipsSet';\r\n\r\n\r\n// Это не обязательно, т.к. все в в index на самом деле\r\n//import './App.css';\r\n\r\nimport { getRandomInt, codeCoordinate, decodeCoordinate} from './utils/Common';\r\nimport { initialState, reducer } from \"./store\";\r\n\r\n// createGlobalStyle нужен для создания глобальных стилей\r\nimport styled, { createGlobalStyle, css } from 'styled-components';\r\n\r\n// получаем значение для целевой платформы\r\nimport { sberBox } from '@sberdevices/plasma-tokens/typo';\r\n// получаем стилевые объекты для нашего интерфейса\r\nimport { body1, headline2 } from '@sberdevices/plasma-tokens';\r\n\r\n// получаем тему персонажа\r\nimport { darkEva, darkSber, darkJoy } from '@sberdevices/plasma-tokens/themes';\r\n\r\n// получаем цвета для нашего интерфейса\r\nimport { text, background, gradient } from '@sberdevices/plasma-tokens';\r\n\r\nimport { Button } from '@sberdevices/ui';\r\nimport { createArrayTypeNode } from 'typescript';\r\n\r\n//import { IconDownload } from '@sberdevices/plasma-icons';\r\n\r\n\r\n\r\nconst AppStyled = styled.div`\r\n    padding: 30px;\r\n    ${body1}\r\n`;\r\n\r\n// создаем react-компонент c глобальными стилями типографики\r\nconst TypoScale = createGlobalStyle(sberBox);\r\n\r\n// создаем react-компонент для подложки\r\nconst DocStyles = createGlobalStyle`\r\n    /* stylelint-disable-next-line selector-nested-pattern */\r\n    html {\r\n        color: ${text};\r\n        background-color: ${background};\r\n        background-image: ${gradient};\r\n\r\n        /** необходимо залить градиентом всю подложку */\r\n        min-height: 100vh;\r\n    }\r\n`;\r\n// создаем react-компонент для персонажа\r\n//const Theme = createGlobalStyle(darkJoy);\r\n//const Theme = createGlobalStyle(lightJoy);\r\n\r\nconst ThemeBackgroundEva = createGlobalStyle(darkEva);\r\nconst ThemeBackgroundSber = createGlobalStyle(darkSber);\r\nconst ThemeBackgroundJoy = createGlobalStyle(darkJoy);\r\n\r\n// Плазма\r\n//https://plasma.sberdevices.ru/current/?path=/docs/about--page\r\n\r\n\r\nconst initializeAssistant = (getState: any) => {\r\n  console.log('process.env.NODE_ENV=');\r\n  console.log(process.env.NODE_ENV);\r\n  if (process.env.NODE_ENV === \"development\") {\r\n    return createSmartappDebugger({\r\n      token: process.env.REACT_APP_TOKEN ?? \"\",\r\n      initPhrase: `Запусти ${process.env.REACT_APP_SMARTAPP}`,\r\n      getState,\r\n    });\r\n  }\r\n\r\n  return createAssistant({ getState });\r\n};\r\n\r\n\r\nexport const App: FC = memo(() => {\r\n  const [appState, dispatch] = useReducer(reducer, initialState);\r\n  //const [note, setNote] = useState(\"\");\r\n  //const [appState, setAppState] = useState(constFullInitialState);\r\n\r\n  const assistantStateRef = useRef<AssistantAppState>();\r\n  const assistantRef = useRef<ReturnType<typeof createAssistant>>();\r\n\r\n  useEffect(() => {\r\n\r\n    dispatch({type: 'init'});\r\n\r\n    assistantRef.current = initializeAssistant(() => assistantStateRef.current);\r\n\r\n    assistantRef.current.on(\"data\", ({ type, character, navigation, action }: any) => {\r\n      // Из-за того, что React.Strict несмотря на то, что вызов я делаю 1 раз, dispatch срабатывае дважды\r\n      // поэтому сделаем счетчик\r\n      if (character)\r\n      {\r\n        // TODO брать respectfulAppeal из character\r\n        // 'sber' | 'eva' | 'joy';\r\n        //setAppState({...appState, character: character.id, respectfulAppeal: character.id!=='joy'});\r\n        dispatch({type: 'character', character_id: character.id});\r\n      }\r\n      // Где-то он и без меня вызывается, поэтому здесь убрал\r\n      if (action) {\r\n        dispatch(action);\r\n      }\r\n    });\r\n  }, []);\r\n\r\n  useEffect(() => {\r\n    assistantStateRef.current = {\r\n      gameOver: appState.gameOver\r\n      /*\r\n      item_selector: {\r\n        items: appState.notes.map(({ id, title }, index) => ({\r\n          number: index + 1,\r\n          id,\r\n          title,\r\n        })),\r\n      },\r\n        */\r\n    };\r\n  }, [appState.gameOver]);\r\n\r\n  useEffect(() => {\r\n    //assistantRef.current?.sendData({ action: { action_id: 'myMove'} });\r\n    if (appState.actionsToSend.length>0)\r\n    {\r\n      appState.actionsToSend.forEach(element => {\r\n        assistantRef.current?.sendData(element.Action);\r\n      });\r\n      dispatch({type: 'clear_action', id: '0'});\r\n    }\r\n  }, [appState.actionsToSend]);\r\n\r\n  useEffect(() => {\r\n    if (appState.enemyTurn)\r\n    {\r\n      // TODO тест передаем ход игроку\r\n      //setAppState({...appState, enemyTurn: false});\r\n      setTimeout(() => processEnemyMove(), 1200);\r\n    }\r\n  }, [appState.enemyTurn, appState.enemyTurnForce]);\r\n\r\n\r\n\r\n\r\n/*\r\n  // { type: \"lets_fire\", coord_str: codeCoordinate(x,y)})\r\n  function myDispatch(myAction: any)\r\n  {\r\n\r\n    if (myAction.type==='show_ships')\r\n    {\r\n      setAppState({...appState, showHidden: true});\r\n    }\r\n\r\n    if (myAction.type==='game_over_lost')\r\n    {\r\n      setAppState({...appState, gameOver: true, youWin: false\r\n      });\r\n    }\r\n\r\n    if (myAction.type==='game_replay')\r\n    {\r\n      // тот же код, что при иннициализации\r\n      // кроме установки персонажа\r\n      let newAppState=getFullInitialState();\r\n      newAppState.character=appState.character;\r\n      newAppState.respectfulAppeal=appState.respectfulAppeal;\r\n      setAppState(newAppState);\r\n    }\r\n\r\n\r\n    if (myAction.type==='lets_fire')\r\n    if (appState.enemyTurn)\r\n    {\r\n      // тут про сессии можно почитать\r\n      // https://developer.sberdevices.ru/docs/ru/developer_tools/ide/JS_API/session_lifetime_control\r\n      assistantRef.current?.sendData({ action: { action_id: 'myMove'} });\r\n    } else\r\n    {\r\n      //alert(myAction.coord_str);\r\n      let fire_registered=false;\r\n      let coord=decodeCoordinate(myAction.coord_str);\r\n      if (coord)\r\n      {\r\n        let x=coord.x, y=coord.y;\r\n\r\n        let field=appState.enemyField[y][x];\r\n        if (field.containsShip)\r\n        {\r\n          // Попали в корабль\r\n          if (!field.shot)\r\n          {\r\n            // До этого в это поле не попадали\r\n            fire_registered=true;\r\n            let newEnemyField=appState.enemyField.slice();\r\n            newEnemyField[y][x].shot=true;\r\n            let shipId=field.shipId;\r\n            // Проверим, есть ли еще не подбитые его части\r\n            let live_parts=0;\r\n            for (let y = 0; y < 10; y++) {\r\n              for (let x = 0; x < 10; x++) {\r\n                if (newEnemyField[y][x].containsShip && newEnemyField[y][x].shipId===shipId)\r\n                {\r\n                  if (!newEnemyField[y][x].shot)\r\n                    live_parts++;\r\n                }\r\n              }\r\n            }\r\n            // TODO если корабль полностью подбит, рисовать его как-то по-другому\r\n        \r\n            let grid=appState.opponent_board.grid.slice();\r\n            grid[y][x] = Constants.GRID_VALUE_SHIP_HIT;\r\n            //setState({ enemyField: newEnemyField, opponent_board: { ...appState.opponent_board, grid: grid, remaining_hit_points: remaining_hit_points} });\r\n            if (live_parts>0)\r\n              assistantRef.current?.sendData({ action: { action_id: 'fireHit', parameters: { coord: myAction.coord_str} } });\r\n            else\r\n            assistantRef.current?.sendData({ action: { action_id: 'fireDone', parameters: { coord: myAction.coord_str} } });\r\n            if (appState.opponent_board.remaining_hit_points<=1)\r\n            {\r\n              // игрок выиграл\r\n              setAppState({...appState,\r\n                opponent_board: {grid: grid, remaining_hit_points: appState.opponent_board.remaining_hit_points-1},\r\n                enemyField: newEnemyField,\r\n                gameOver: true,\r\n                youWin: true\r\n                });\r\n                assistantRef.current?.sendData({ action: { action_id: 'gameOverWin', parameters: {} } });\r\n            } else {\r\n              // просто очередное попадание, ход не переходит\r\n              setAppState({...appState,\r\n              opponent_board: {grid: grid, remaining_hit_points: appState.opponent_board.remaining_hit_points-1},\r\n              enemyField: newEnemyField\r\n              });\r\n            }\r\n\r\n          } else {\r\n            // Повторное попадание. Ход считаем, что не переходит\r\n            assistantRef.current?.sendData({ action: { action_id: 'fireAgain', parameters: { coord: myAction.coord_str} } });\r\n          }\r\n        } else {\r\n          // Попали в воду\r\n          let grid=appState.opponent_board.grid.slice();\r\n          if (grid[y][x] === Constants.GRID_VALUE_WATER)\r\n          {\r\n            // До этого туда не стреляли\r\n            fire_registered=true;\r\n            // хотя это бы и не обязательно делать (заполнять enemyField для воды), все равно попадание у нас контролируется по-другому,\r\n            // но для корректности данных лучше так сделать\r\n            let newEnemyField=appState.enemyField.slice();\r\n            newEnemyField[y][x].shot=true;\r\n            //\r\n            grid[y][x] = Constants.GRID_VALUE_WATER_HIT;\r\n            //this.setState({ enemyField: newEnemyField, opponent_board: { ...this.state.opponent_board, grid: grid} });\r\n            setAppState({...appState,\r\n              opponent_board: { ...appState.opponent_board, grid: grid}, enemyField: newEnemyField,\r\n              enemyTurn: true\r\n            });\r\n          }\r\n          assistantRef.current?.sendData({ action: { action_id: 'fireMiss', parameters: { coord: myAction.coord_str} } });\r\n        }\r\n      }\r\n\r\n      // Теперь он сам стреляет\r\n      // (сделано специально, чтобы в любом случае произошла проверка, чтобы игровой процесс не остановился по какой-нибудь причине)\r\n      //setTimeout(() => processEnemyMove(), 1200);\r\n\r\n    }\r\n  }\r\n\r\n  // вернет true, если оппонент попал\r\n  // в этом случае ход не переходит\r\n  function fireMyBoard(alphabetical_coord: string)\r\n  {\r\n    const coordinate=decodeCoordinate(alphabetical_coord);\r\n    if (coordinate==null)\r\n      return false;\r\n    const x=coordinate.x;\r\n    const y=coordinate.y;\r\n\r\n    let fire_registered=false;\r\n\r\n    let field=appState.myField[y][x];\r\n    if (field.containsShip)\r\n    {\r\n      // Попали в корабль\r\n      if (!field.shot)\r\n      {\r\n        // До этого в это поле не попадали\r\n        fire_registered=true;\r\n        let newEnemyField=appState.myField.slice();\r\n        newEnemyField[y][x].shot=true;\r\n        let shipId=field.shipId;\r\n        // Проверим, есть ли еще не подбитые его части\r\n        let live_parts=0;\r\n        for (let y = 0; y < 10; y++) {\r\n          for (let x = 0; x < 10; x++) {\r\n            if (newEnemyField[y][x].containsShip && newEnemyField[y][x].shipId===shipId)\r\n            {\r\n              if (!newEnemyField[y][x].shot)\r\n                live_parts++;\r\n            }\r\n          }\r\n        }\r\n        // TODO если корабль полностью подбит, рисовать его как-то по-другому\r\n    \r\n        let grid=appState.my_board.grid.slice();\r\n        grid[y][x] = Constants.GRID_VALUE_SHIP_HIT;\r\n        setAppState({...appState, myField: newEnemyField, my_board: { ...appState.my_board, grid: grid} });\r\n        return true;\r\n      } else {\r\n        // Повторное попадание\r\n      }\r\n    } else {\r\n      // Попали в воду\r\n      let grid=appState.my_board.grid.slice();\r\n      if (grid[y][x] === Constants.GRID_VALUE_WATER)\r\n      {\r\n        // До этого туда не стреляли\r\n        fire_registered=true;\r\n        let newEnemyField=appState.myField.slice();\r\n        newEnemyField[y][x].shot=true;\r\n        grid[y][x] = Constants.GRID_VALUE_WATER_HIT;\r\n        setAppState({...appState, myField: newEnemyField, my_board: { ...appState.my_board, grid: grid} });\r\n      }\r\n    }\r\n    return false;\r\n\r\n  }\r\n  */\r\n\r\n  function processEnemyMove()\r\n  {\r\n    // только в свой ход\r\n    if (!appState.enemyTurn)\r\n      return;\r\n\r\n    const offsets=[{x:-1,y:-1}, {x:0,y:-1}, {x:1,y:-1},\r\n      {x:-1,y:0}, {x:0,y:0}, {x:1,y:0},\r\n      {x:-1,y:1}, {x:0,y:1}, {x:1,y:1},\r\n    ];\r\n\r\n    const offsets4=[{x:0,y:-1},{x:-1,y:0},{x:1,y:0},{x:0,y:1}];\r\n\r\n    let field=appState.myField;\r\n    // Первый проход, ищем точки, где рядом есть с попаданиями\r\n    // они будут иметь признак первичных\r\n    // а уже на втором проходе будет происходить поиск, куда можно в принципе выстрелить\r\n    // поэтому если координата будет иметь признак первичной, но стрелять туда нельзя, она в массив не попадет\r\n    let primary_area=Array.from(Array(10), _ => Array(10).fill(0));\r\n    // если в этой координате подбитый корабль\r\n    // найдем, есть ли не подбитые в 4-х направлениях от него\r\n    // и если есть, то это он сам (т.к. нельзя ставить рядом)\r\n    // Заодно заполним список живых кораблей\r\n    let live_ships=new Set();\r\n    for (let y = 0; y < 10; y++) {\r\n      for (let x = 0; x < 10; x++) {\r\n        for (let i=0; i<offsets4.length; i++){\r\n          if (field[y][x].containsShip&&!field[y][x].shot) {\r\n            live_ships.add(field[y][x].shipId);\r\n          }\r\n          let _x=x+offsets4[i].x;\r\n          let _y=y+offsets4[i].y;\r\n          if (_x>=0&&_x<10&&_y>=0&&_y<10&&field[_y][_x].containsShip&&field[_y][_x].shot)\r\n          {\r\n            primary_area[y][x]=1;\r\n            break;\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    let primary_targets=[];\r\n    let targets=[];\r\n\r\n    // составим массив координат, куда враг может выстрелить\r\n    for (let y = 0; y < 10; y++) {\r\n      for (let x = 0; x < 10; x++) {\r\n        // если туда еще не стреляли\r\n        let canFire=true;\r\n        if (!field[y][x].shot)\r\n        {\r\n          // и вблизи нет подбитых (полностью) кораблей\r\n          for (let i=0; i<offsets.length; i++){\r\n            let _x=x+offsets[i].x;\r\n            let _y=y+offsets[i].y;\r\n            if (_x>=0&&_x<10&&_y>=0&&_y<10&&field[_y][_x].containsShip&&field[_y][_x].shot)\r\n            {\r\n              if (!live_ships.has(field[_y][_x].shipId))\r\n              {\r\n                canFire=false;\r\n                break;\r\n              }\r\n            }\r\n          }\r\n          if (canFire)\r\n          {\r\n            targets.push({y:y, x:x});\r\n            if (primary_area[y][x]===1)\r\n              primary_targets.push({y:y, x:x});\r\n          }\r\n        }\r\n      }\r\n    }\r\n    // На всякий случай проверка, что есть куда выстрелить (по идее в этом случае игра уже закончена)\r\n    if (targets.length>0)\r\n    {\r\n      // Координаты выстрела\r\n      let fire_coord=primary_targets.length>0?primary_targets[getRandomInt(0, primary_targets.length-1)]:targets[getRandomInt(0, targets.length-1)];\r\n\r\n      let alphabetical_coord=codeCoordinate(fire_coord.x, fire_coord.y);\r\n\r\n      /*\r\n      if (fireMyBoard(alphabetical_coord))\r\n      {\r\n        // если попал, проверяем, победа это или запускаем следующий ход оппонента\r\n        let playerLivesCount=0;\r\n        for (let y = 0; y < 10; y++) {\r\n          for (let x = 0; x < 10; x++) {\r\n            // если туда еще не стреляли\r\n            if (!field[y][x].shot&&field[y][x].containsShip)\r\n              playerLivesCount++;\r\n          }\r\n        }\r\n        //if (playerLivesCount>0)\r\n        //  setTimeout(() => processEnemyMove(), 1200);\r\n        //else\r\n        if (playerLivesCount<=0)\r\n        {\r\n          //setAppState({...appState, gameOver: true, youWin: false});\r\n          assistantRef.current?.sendData({ action: { action_id: 'gameOverLost', parameters: {} } });\r\n        }\r\n        return;\r\n      }\r\n      */\r\n     dispatch({ type: \"enemy_fire\", coord_str: alphabetical_coord});\r\n    }\r\n    // В остальных случаях ход переходит к игроку\r\n    //setAppState({...appState, enemyTurn: false});\r\n  }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n  function _renderResult() {\r\n\r\n    //const { game, playerId, winnerId } = this.props;\r\n    const {youWin} = appState;\r\n  \r\n    const message = youWin ? 'Вы победили!' : 'Вы потерпели крушение, сухопутный!';\r\n  \r\n    //setDocumentTitle(`${message} · #${game.id}`);\r\n  \r\n    return (\r\n      <div id=\"game_result\">\r\n        <header>\r\n        {/*<Logo/>*/}\r\n          <h1>Игра окончена</h1>\r\n          <p>{message}</p>\r\n        </header>\r\n        {/*<Link to=\"/\">Back to home</Link>*/}\r\n      </div>\r\n    );\r\n  }\r\n  \r\n  function _renderOpponentBoard() {\r\n    //const { dispatch, game, gameChannel, playerId, currentTurn, readyForBattle } = this.props;\r\n  \r\n    /*\r\n    if (!readyForBattle) return (\r\n        <Instructions\r\n            readyForBattle={readyForBattle}\r\n            playerIsAttacker={playerId === game.attacker}/>\r\n    );\r\n     */\r\n  \r\n    //const opponentBoard = this.state.opponent_board_0;\r\n    // а вот через data к ним можно бы обратиться только внутри OpponentBoard\r\n    const remaining_hit_points = appState.opponent_board.remaining_hit_points;\r\n  \r\n    return (\r\n      <div id=\"opponents_board_container\">\r\n        <header><h2>Поле для стрельбы</h2></header>        \r\n        <OpponentBoard\r\n          //dispatch={dispatch}\r\n          //gameChannel={gameChannel}\r\n          data={appState.opponent_board}\r\n          showHidden={appState.showHidden}\r\n          //playerId={playerId}\r\n          //currentTurn={currentTurn}\r\n          //onClickBoard={() => dispatch({ type: \"add_note\", note: \"123\" })}\r\n          // TODO\r\n          onClickBoard={(x:any, y:any) => dispatch({ type: \"lets_fire\", coord_str: codeCoordinate(x,y)})}\r\n        />\r\n        <p>Попаданий до победы: {remaining_hit_points}</p>\r\n      </div>\r\n    );\r\n  \r\n  }\r\n  \r\n  \r\n  // 559x568, 768x400, 959x400, 1920x1080\r\n  function _renderGameContent() {\r\n    if (appState.gameOver) return _renderResult();\r\n  \r\n    return (\r\n      <section id=\"main_section\">\r\n        {\r\n          <Header\r\n          //game={GameShowView}\r\n          //playerId={playerId}\r\n          enemyTurn={appState.enemyTurn}\r\n          respectfulAppeal={appState.respectfulAppeal}\r\n          >\r\n          </Header>\r\n        }\r\n        <section id=\"boards_container\">\r\n          <div id=\"my_board_container\">\r\n            <header><h2>Свои корабли</h2></header>\r\n            <MyBoard\r\n              //dispatch={dispatch}\r\n              //gameChannel={gameChannel}\r\n              //selectedShip={selectedShip}\r\n              data={appState.my_board}\r\n            />\r\n          </div>\r\n          {\r\n            _renderOpponentBoard()\r\n          }\r\n        </section>\r\n      </section>\r\n    );\r\n  \r\n  }\r\n  \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n  return (\r\n    <AppStyled>\r\n    {/* Используем глобальные react-компоненты один раз */}\r\n    <TypoScale />\r\n    <DocStyles />\r\n    {(() => {\r\n                switch (appState.character) {\r\n                    case 'sber':\r\n                        return <ThemeBackgroundSber />;\r\n                    case 'eva':\r\n                        return <ThemeBackgroundEva />;\r\n                    case 'joy':\r\n                        return <ThemeBackgroundJoy />;\r\n                    default:\r\n                        return;\r\n                }\r\n            })()}    \r\n    {/*<Theme />*/}\r\n    {/*<Button onClick={() => doneNote(\"Test!\")}>Normal Button</Button>*/}\r\n    <main id=\"game_show\" className=\"view-container\">\r\n      {_renderGameContent()}\r\n      {/*\r\n      <form\r\n        onSubmit={(event) => {\r\n          event.preventDefault();\r\n          dispatch({ type: \"add_note\", note });\r\n          setNote(\"\");\r\n        }}\r\n      >\r\n        <input\r\n          className=\"add-note\"\r\n          type=\"text\"\r\n          placeholder=\"Add Note\"\r\n          value={note}\r\n          onChange={({ target: { value } }) => setNote(value)}\r\n          required\r\n          autoFocus\r\n        />\r\n      </form>\r\n      <ul className=\"notes\">\r\n        {appState.notes.map((note, index) => (\r\n          <li className=\"note\" key={note.id}>\r\n            <span>\r\n              <span style={{ fontWeight: \"bold\" }}>{index + 1}. </span>\r\n              <span\r\n                style={{\r\n                  textDecorationLine: note.completed ? \"line-through\" : \"none\",\r\n                }}\r\n              >\r\n                {note.title}\r\n              </span>\r\n            </span>\r\n            <input\r\n              className=\"done-note\"\r\n              type=\"checkbox\"\r\n              checked={note.completed}\r\n              onChange={() => dispatch({ type: \"done_note\", id: note.id })}\r\n            />\r\n          </li>\r\n        ))}\r\n      </ul>\r\n      */}\r\n    </main>\r\n    </AppStyled>\r\n  );\r\n});\r\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport {App} from './App';\r\nimport reportWebVitals from './reportWebVitals';\r\n\r\nReactDOM.render(\r\n  <React.StrictMode>\r\n    <App />\r\n  </React.StrictMode>,\r\n  document.getElementById('root')\r\n);\r\n\r\n// If you want to start measuring performance in your app, pass a function\r\n// to log results (for example: reportWebVitals(console.log))\r\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\r\nreportWebVitals();\r\n"],"sourceRoot":""}