{"version":3,"sources":["components/header.js","constants/index.js","constants/messages.js","components/board.js","components/my_board.js","components/opponent_board.js","utils/Common.js","utils/placeShip.js","utils/checkPlaceShip.js","utils/standardShipsSet.js","store.ts","App.tsx","reportWebVitals.ts","index.tsx"],"names":["Header","this","props","enemyTurn","respectfulAppeal","id","_titleText","React","Component","letters","Board","data","showHidden","grid","rows","_buildRowHeader","y","cells","className","x","push","_renderCell","value","key","classes","_cellId","_cellClasses","onClick","_handleCellClick","onDoubleClick","e","preventDefault","onMouseOver","_handleCellMouseOver","onMouseOut","_handleCellMouseOut","_cellValue","values","i","_boardClasses","_renderRows","MyBoard","_toggleCellClasses","selectedShip","classnames","pointer","cell","ship","Constants","ref","orientation","size","inbounds","overlapping","coords","OpponentBoard","onClickBoard","playerId","currentTurn","hit","getRandomInt","min","max","Math","ceil","floor","random","codeCoordinate","decodeCoordinate","s","s2","replaceAll","toUpperCase","digits_alphabetical","length","replace","toString","includes","substring","parseInt","field","direction","startSquare","containsShip","shipId","offsets","j","Ship","incrementId","hitpoints","latestId","placeVarious","enemyField","shot","isShipVisible","variableSet","l","checkPlaceShip","placeShip","getFullInitialState","boardInitialState","initial_myField","Array","myShips","initial_enemyField","enemyShips","val_in_line","enemy_val_in_line","forEach","ship0","my_grid","enemy_grid","remaining_hit_points","my_line","enemy_line","fieldVal","fieldVal_0","my_board","myField","opponent_board","getBoardInitialState","actionsToSend","debugLastUserTalkCoord","character","enemyTurnForce","gameOver","youWin","emptyRow","emptyGrid","initialState","reducer","state","action","type","character_id","slice","coord","coord_str","newMyField","live_parts","Action","action_id","parameters","playerLivesCount","newEnemyField","Error","AppStyled","styled","div","body1","TypoScale","createGlobalStyle","sberBox","DocStyles","text","background","gradient","ThemeBackgroundEva","darkEva","ThemeBackgroundSber","darkSber","ThemeBackgroundJoy","darkJoy","App","memo","useReducer","appState","dispatch","assistantStateRef","useRef","assistantRef","myByCode","result","codePointAt","_renderOpponentBoard","useEffect","getState","current","console","log","process","createAssistant","on","navigation","element","sendData","setTimeout","offsets4","primary_area","from","_","fill","live_ships","Set","add","_x","_y","primary_targets","targets","canFire","has","fire_coord","alphabetical_coord","processEnemyMove","message","_renderResult","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.a091dae5.chunk.js","sourcesContent":["import React, {Component} from 'react';\r\nimport PropTypes from 'prop-types'\r\n//import { setDocumentTitle }   from '../../utils';\r\n//import MyBoard from \"./my_board\";\r\n\r\nexport default class Header extends React.Component {\r\n\r\n  componentDidUpdate() {\r\n    //const { game } = this.props;\r\n    // TODO\r\n    //setDocumentTitle(`${this._titleText()} · #${game.id}`);\r\n  }\r\n\r\n  _titleText() {\r\n    //const { game, playerId, currentTurn, my_board, opponents_board } = this.props;\r\n    //const { readyForBattle } = game;\r\n    //let readyForBattle=true;\r\n    const { enemyTurn, respectfulAppeal } = this.props;\r\n\r\n    /*\r\n\r\n    if (!my_board.ready) {\r\n      return 'Place your ships';\r\n    } else if (!opponents_board || !opponents_board.ready) {\r\n      return 'Waiting for opponent';\r\n    } else if (currentTurn && currentTurn === playerId) {\r\n      return 'Your turn!';\r\n    } else if (currentTurn && currentTurn != playerId) {\r\n      return 'Your opponent\\'s turn!';\r\n    } else {\r\n      return 'Let the battle begin';\r\n    }\r\n     */\r\n    if (enemyTurn===true) {\r\n      return respectfulAppeal===false?'Ход твоего оппонента!':'Ход Вашего оппонента!';\r\n    } else {\r\n      return respectfulAppeal===false?'Твой ход!':'Ваш ход!';\r\n    }\r\n    \r\n  }\r\n\r\n  _messageText() {\r\n    const { enemyTurn, respectfulAppeal } = this.props;\r\n    /*\r\n    const { game, playerId, currentTurn } = this.props;\r\n    const { my_board, opponents_board, readyForBattle } = game;\r\n\r\n    if (!my_board.ready) {\r\n      return 'Use the instructions below';\r\n    } else if (!opponents_board || !opponents_board.ready) {\r\n      return 'Battle will start as soon as your opponent is ready';\r\n    } else if (currentTurn && currentTurn === playerId) {\r\n      return 'Click on your shooting grid to open fire!';\r\n    } else if (currentTurn && currentTurn != playerId) {\r\n      return 'Wait for your opponent to shoot...';\r\n    } else {\r\n      return 'Let the battle begin';\r\n    }\r\n     */\r\n    if (enemyTurn===true) {\r\n      return respectfulAppeal===false?'Ход твоего оппонента!':'Ход Вашего оппонента!';\r\n    } else {\r\n      return respectfulAppeal===false?'Твой ход!':'Ваш ход!';\r\n    }\r\n  }\r\n\r\n  render() {\r\n    return (\r\n      <header id=\"game_header\">\r\n        <h1>{this._titleText()}</h1>\r\n        {/*<p>{this._messageText()}</p>*/}\r\n      </header>\r\n    );\r\n  }\r\n}\r\n","export default {\r\n\r\n  // Session\r\n  SESSION_SET_PLAYER: 'SESSION_SET_PLAYER',\r\n\r\n  //  Home\r\n  HOME_NEW_GAME: 'HOME_NEW_GAME',\r\n  HOME_SET_CURRENT_GAMES: 'HOME_SET_CURRENT_GAMES',\r\n\r\n  // Game\r\n  GAME_SET_CHANNEL: 'GAME_SET_CHANNEL',\r\n  GAME_PLAYER_JOINED: 'GAME_PLAYER_JOINED',\r\n  GAME_PLAYER_LEFT: 'GAME_PLAYER_LEFT',\r\n  GAME_SET_GAME: 'GAME_SET_GAME',\r\n  GAME_ADD_MESSAGE: 'GAME_ADD_MESSAGE',\r\n  GAME_SETUP_SELECT_SHIP: 'GAME_SETUP_SELECT_SHIP',\r\n  GAME_OPPONENTS_BOARD_UPDATE: 'GAME_OPPONENTS_BOARD_UPDATE',\r\n  GAME_RESET: 'GAME_RESET',\r\n  GAME_OVER: 'GAME_OVER',\r\n  GAME_ERROR: 'GAME_ERROR',\r\n\r\n  //Ships\r\n  SHIP_ORIENTATION_HORIZONTAL: 'horizontal',\r\n  SHIP_ORIENTATION_VERTICAL: 'vertical',\r\n\r\n  // Boards\r\n  GRID_VALUE_WATER: '·',\r\n  GRID_VALUE_SHIP: '/',\r\n  GRID_VALUE_WATER_HIT: 'O',\r\n  GRID_VALUE_SHIP_HIT: '*',\r\n};\r\n","\r\nexport const letters = ['А', 'Б', 'В', 'Г', 'Д', 'Е', 'Ж', 'З', 'И', 'К'];\r\n\r\nexport const hello_messages = ['Привет!'];\r\nexport const hit_messages = ['Неплохо для слепого!'];\r\nexport const miss_messages = ['Мазила!', 'Мимо!', 'Промах!'];\r\nexport const kill_messages = ['Убил!'];\r\nexport const dont_understand = ['Моя твоя не понимай!'];\r\n\r\n","import React, {PropTypes} from 'react';\r\nimport classnames         from 'classnames';\r\nimport Constants from '../constants';\r\nimport {letters} from '../constants/messages';\r\n//import { setGame }        from '../../actions/game';\r\n\r\nexport default class Board extends React.Component {\r\n\r\n  constructor(props)\r\n  {\r\n    super(props);\r\n  }\r\n\r\n  _renderRows(data, showHidden) {\r\n\r\n    // showHidden важно только для opponent_board\r\n    const { grid } = data;\r\n\r\n    let rows = [this._buildRowHeader()];\r\n\r\n    for (let y = 0; y < 10; y++) {\r\n      let cells = [<div key={`header-${y}`} className=\"header cell\">{y + 1}</div>];\r\n\r\n      for (let x = 0; x < 10; x++) {\r\n        //cells.push(this._renderCell(y, x, grid[`${y}${x}`]));\r\n        // 15.02.2021 у нас это не строка 00, 01, 02 и т.д., а двухмерный массив\r\n        cells.push(this._renderCell(y, x, grid[y][x], showHidden));\r\n      }\r\n\r\n      rows.push(<div className=\"row\" key={y}>{cells}</div>);\r\n    }\r\n/*\r\n      let rows = [this._buildRowHeader()];\r\n\r\n      for (let y = 0; y < 10; y++) {\r\n          let cells = [<div key={`header-${y}`} className=\"header cell\">{y + 1}</div>];\r\n\r\n          for (let x = 0; x < 10; x++) {\r\n              cells.push(this._renderCell(y, x, '*'));\r\n          }\r\n\r\n          rows.push(<div className=\"row\" key={y}>{cells}</div>);\r\n      }\r\n*/\r\n\r\n\r\n    return rows;\r\n  }\r\n\r\n  _renderCell(y, x, value, showHidden) {\r\n    const key = `${y}${x}`;\r\n    const id = this._cellId(key);\r\n    const classes = this._cellClasses(value, showHidden);\r\n\r\n    return (\r\n      <div\r\n        id={this._cellId(key)}\r\n        className={classes}\r\n        key={key}\r\n        onClick={this._handleCellClick(y, x, value)}\r\n        onDoubleClick={(e) => e.preventDefault()}\r\n        onMouseOver={(y,x)=>this._handleCellMouseOver(y, x)}\r\n        onMouseOut={(y,x)=>this._handleCellMouseOut(y, x)}>{this._cellValue(value)}</div>\r\n    );\r\n  }\r\n\r\n  _buildRowHeader() {\r\n    let values = [<div key=\"empty\" className=\"header cell\"></div>];\r\n\r\n    for (var i = 0; i < 10; ++i) {\r\n      //  values.push(<div key={i} className=\"header cell\">{String.fromCharCode(i + 65)}</div>);\r\n      values.push(<div key={i} className=\"header cell\">{letters[i]}</div>);\r\n    }\r\n\r\n\r\n\r\n    return (\r\n      <div key=\"col-headers\" className=\"row\">\r\n        {values}\r\n      </div>\r\n    );\r\n  }\r\n\r\n  render() {\r\n      // 14.02.2012 TODO\r\n    const { data, showHidden } = this.props;\r\n    //if (!data) return false;\r\n\r\n    const classes = this._boardClasses();\r\n\r\n    return (\r\n      <div className={classes}>\r\n        {this._renderRows(data, showHidden)}\r\n      </div>\r\n    );\r\n  }\r\n}\r\n","import React, {PropTypes} from 'react';\r\nimport classnames         from 'classnames';\r\nimport Board              from './board';\r\nimport Constants          from '../constants';\r\n//import { setGame }        from '../../actions/game';\r\n//import { setError }       from '../../actions/game';\r\n\r\nexport default class MyBoard extends Board {\r\n\r\n    _handleCellClick(y, x, value) {\r\n    //const { selectedShip, gameChannel, dispatch } = this.props;\r\n    //const key = `${y}${x}`;\r\n\r\n    // 14.02.2021 Добавил\r\n    //const ready=true;\r\n    //\r\n\r\n    // Это было в actions\r\n    //  function setGame(game) {\r\n    //    return {\r\n    //      type: Constants.GAME_SET_GAME,\r\n    //      game: game,\r\n    //    };\r\n    //  }\r\n\r\n\r\n    return (e) => {\r\n      //if (selectedShip.id === null) return false;\r\n      if (value != Constants.GRID_VALUE_WATER) return false;\r\n\r\n      //const ship = {\r\n      //  x: x,\r\n      //  y: y,\r\n      //  size: selectedShip.size,\r\n      //  orientation: selectedShip.orientation,\r\n      //};\r\n\r\n      // TODO 08.02.2021\r\n      //gameChannel.push('game:place_ship', { ship: ship })\r\n      //.receive('ok', (payload) => dispatch(setGame(payload.game)));\r\n      //.receive('error', (payload) => dispatch(setError(payload.reason)));\r\n\r\n      return false;\r\n\r\n    };\r\n  }\r\n\r\n  _handleCellMouseOver(y, x) {\r\n    return this._toggleCellClasses(y, x);\r\n  }\r\n\r\n  _handleCellMouseOut(y, x) {\r\n    return this._toggleCellClasses(y, x);\r\n  }\r\n\r\n  _toggleCellClasses(y, x) {\r\n      // TODO это расстановка\r\n      /*\r\n    const { selectedShip } = this.props;\r\n\r\n    if (selectedShip.size === 0) return false;\r\n\r\n    const { size, orientation } = selectedShip;\r\n\r\n    const className = this._validCoords(y, x, orientation, size) ? 'ship-shape' : 'ship-shape-invalid';\r\n\r\n    return (e) => {\r\n      for (var i = 0; i < size; i++) {\r\n        const coords = orientation === 'horizontal' ? `${y}${x + i}` : `${y + i}${x}`;\r\n        let cell = document.getElementById(coords);\r\n        if (!cell) break;\r\n        cell.classList.toggle(className);\r\n      }\r\n    };\r\n       */\r\n  }\r\n\r\n  _cellValue(value) {\r\n    return false;\r\n  }\r\n\r\n  _boardClasses() {\r\n    const { selectedShip } = this.props;\r\n\r\n    return classnames({\r\n      grid: true,\r\n      pointer: selectedShip && selectedShip.id != null,\r\n    });\r\n  }\r\n\r\n  _cellClasses(value, showHidden) {\r\n    return classnames({\r\n      cell: true,\r\n      ship: value === Constants.GRID_VALUE_SHIP,\r\n      'ship-hit': value === Constants.GRID_VALUE_SHIP_HIT,\r\n      'water-hit': value === Constants.GRID_VALUE_WATER_HIT,\r\n    });\r\n  }\r\n\r\n  _cellId(ref) {\r\n    return ref;\r\n  }\r\n\r\n  _validCoords(y, x, orientation, size) {\r\n    const { data } = this.props;\r\n    let inbounds;\r\n\r\n    if (orientation === 'horizontal') {\r\n      inbounds = (x + size) <= 10;\r\n    } else {\r\n      inbounds = (y + size) <= 10;\r\n    }\r\n\r\n    let overlapping = false;\r\n\r\n    for (var i = 0; i < size; i++) {\r\n      const coords = orientation === 'horizontal' ? `${y}${x + i}` : `${y + i}${x}`;\r\n      if (data.grid[coords] != Constants.GRID_VALUE_WATER) {\r\n        overlapping = true;\r\n        break;\r\n      }\r\n    }\r\n\r\n    return inbounds && !overlapping;\r\n  }\r\n}\r\n","import React, {PropTypes} from 'react';\r\nimport classnames         from 'classnames';\r\nimport Board              from './board';\r\nimport Constants          from '../constants';\r\n//import { setGame }        from '../../actions/game';\r\n\r\nexport default class OpponentBoard extends Board {\r\n\r\n  constructor(props) {\r\n    super(props);\r\n\r\n  }\r\n\r\n  _handleCellClick(y, x, value) {\r\n    //const { gameChannel, currentTurn, playerId, dispatch } = this.props;\r\n\r\n    //if (currentTurn !== playerId) return false;\r\n\r\n    //const key = `${y}${x}`;\r\n\r\n    // Это было в actions\r\n    //function setGame(game) {\r\n    //  return {\r\n    //    type: Constants.GAME_SET_GAME,\r\n    //    game: game,\r\n    //  };\r\n    //}\r\n\r\n    return (e) => { \r\n      this.props.onClickBoard(x, y);\r\n    }\r\n\r\n\r\n    //return (e) => {\r\n    //  if (value != Constants.GRID_VALUE_WATER) return false;\r\n\r\n      //gameChannel.push('game:shoot', { y: y, x: x })\r\n      //.receive('ok', (payload) => {\r\n      //  dispatch(setGame(payload.game));\r\n      //})\r\n      //.receive('error', (payload) => console.log(payload));\r\n\r\n\r\n    //};\r\n  }\r\n\r\n  _handleCellMouseOver(y, x) {\r\n    return false;\r\n  }\r\n\r\n  _cellValue(value) {\r\n    return '';\r\n  }\r\n\r\n  _boardClasses() {\r\n    const { playerId, currentTurn } = this.props;\r\n\r\n    return classnames({\r\n      grid: true,\r\n      pointer: playerId === currentTurn,\r\n    });\r\n  }\r\n\r\n  _cellClasses(value, showHidden) {\r\n    return classnames({\r\n      cell: true,\r\n      // TODO только во время отладки\r\n      ship: showHidden && value === Constants.GRID_VALUE_SHIP,\r\n      //\r\n      hit: value === Constants.GRID_VALUE_SHIP_HIT,\r\n      'water-hit': value === Constants.GRID_VALUE_WATER_HIT,\r\n    });\r\n  }\r\n\r\n  _cellId(ref) {\r\n    return false;\r\n  }\r\n\r\n  _handleCellMouseOut(e) {\r\n    return false;\r\n  }\r\n}\r\n","\r\nimport { letters } from '../constants/messages';\r\n\r\n\r\nexport function getRandomArbitrary(min, max) {\r\n    return Math.random() * (max - min) + min;\r\n}\r\n\r\nexport function getRandomInt(min, max) {\r\n    min = Math.ceil(min);\r\n    max = Math.floor(max);\r\n    return Math.floor(Math.random() * (max - min + 1)) + min;\r\n}\r\n\r\nexport function codeCoordinate(x, y)\r\n{\r\n  return letters[x]+(y+1);\r\n}\r\n\r\n\r\nexport function decodeCoordinate(s)\r\n{\r\n  let result=null;\r\n\r\n  //s=String.fromCodePoint(1072,1072,32,1086,1076,1080,1085);\r\n\r\n  //s=s.replaceAll(\"1\", \" ОДИН \");\r\n\r\n  let y=-1;\r\n  let s2=s.replaceAll(\"-\", \" \").toUpperCase();\r\n  const digits_alphabetical=['ОДИН', 'ДВА', 'ТРИ', 'ЧЕТЫРЕ', 'ПЯТЬ', 'ШЕСТЬ', 'СЕМЬ', 'ВОСЕМЬ', 'ДЕВЯТЬ', 'ДЕСЯТЬ'];\r\n  for (let i=0; i<digits_alphabetical.length; i++)\r\n  {\r\n    s2=s2.replace(digits_alphabetical[i], (i+1).toString());\r\n  }\r\n\r\n  s2=s2.replaceAll(\" \", \"\");\r\n\r\n  // 08.04.2021\r\n  // все, что не на первом и не на последнем месте и не цифра, заменяем на пробел\r\n  // пока такая простейшая проверка на координаты типа Игорь-3\r\n  for (let i=1; i<s2.length-1; i++)\r\n  {\r\n    if (!('0123456789'.includes(s2[i])))\r\n    {\r\n      s2 = s2.substring(0, i) + ' ' + s2.substring(i + 1);\r\n    }\r\n  }\r\n  //\r\n\r\n  s2=s2.replaceAll(\" \", \"\");\r\n\r\n  if (s2.length===3&&s2.substring(1)===\"10\")\r\n  {\r\n    y=9;\r\n  } else if (s2.length===2) {\r\n    if ('0123456789'.includes(s2.substring(2)))\r\n      y=parseInt(s2.substring(1))-1;\r\n  }\r\n  if (y>=0)\r\n  {\r\n    switch (s2.substring(0,1))\r\n    {\r\n      case 'А':\r\n        result={x:0, y:y};\r\n        break;\r\n      case 'Б':\r\n        result={x:1, y:y};\r\n        break;\r\n      case 'В':\r\n        result={x:2, y:y};\r\n        break;\r\n      case 'Г':\r\n        result={x:3, y:y};\r\n        break;\r\n      case 'Д':\r\n        result={x:4, y:y};\r\n        break;\r\n      case 'Е':\r\n        result={x:5, y:y};\r\n        break;\r\n      case 'Ж':\r\n        result={x:6, y:y};\r\n        break;\r\n      case 'З':\r\n        result={x:7, y:y};\r\n        break;\r\n      case 'И':\r\n        result={x:8, y:y};\r\n        break;\r\n      case 'К':\r\n        result={x:9, y:y};\r\n        break;\r\n    }\r\n  }\r\n  //return result;\r\n\r\n  result={x:3, y:2};\r\n  return result;\r\n\r\n}","// небольшая функция-сниппет, которая добавляет корабль на поле\r\n// сдвиг на единицу появился из-за отсчета индекса массива с нуля\r\n\r\nexport default (field, ship) => {\r\n    switch(ship.direction) {\r\n        case 'right': \r\n        for (let i = ship.startSquare.x - 1; i < ship.startSquare.x - 1 + ship.size; i++) {\r\n            field[ship.startSquare.y - 1][i].containsShip = true;\r\n            field[ship.startSquare.y - 1][i].shipId = ship.id;\r\n        }\r\n        break;\r\n        case 'down': \r\n        for (let i = ship.startSquare.y - 1; i < ship.startSquare.y - 1 + ship.size; i++) {\r\n            field[i][ship.startSquare.x - 1].containsShip = true;\r\n            field[i][ship.startSquare.x - 1].shipId = ship.id;\r\n        }\r\n        break;\r\n        default:\r\n    }\r\n}\r\n","\r\nexport default (field, ship) => {\r\n    const offsets=[{x:-1,y:-1}, {x:0,y:-1}, {x:1,y:-1},\r\n        {x:-1,y:0}, {x:0,y:0}, {x:1,y:0},\r\n        {x:-1,y:1}, {x:0,y:1}, {x:1,y:1},\r\n    ];\r\n    switch(ship.direction) {\r\n        case 'right':\r\n            for (let i = ship.startSquare.x - 1; i < ship.startSquare.x - 1 + ship.size; i++) {\r\n                //field[ship.startSquare.y - 1][i].containsShip = true;\r\n                //field[ship.startSquare.y - 1][i].shipId = ship.id;\r\n                for (let j=0; j<offsets.length; j++)\r\n                {\r\n                    let y=offsets[j].y+ship.startSquare.y - 1;\r\n                    let x=offsets[j].x+i;\r\n                    if (x<0||y<0||x>=10|y>=10)\r\n                    {\r\n                        // корабль находится в углу поля, там других кораблей нет\r\n                    } else {\r\n                        if (field[y][x].containsShip)\r\n                            return false;\r\n                    }\r\n                }\r\n\r\n            }\r\n            break;\r\n        case 'down':\r\n            for (let i = ship.startSquare.y - 1; i < ship.startSquare.y - 1 + ship.size; i++) {\r\n                //field[i][ship.startSquare.x - 1].containsShip = true;\r\n                //field[i][ship.startSquare.x - 1].shipId = ship.id;\r\n                for (let j=0; j<offsets.length; j++)\r\n                {\r\n                    let y=offsets[j].y+i;\r\n                    let x=offsets[j].x+ship.startSquare.x - 1;\r\n                    if (x<0||y<0||x>=10|y>=10)\r\n                    {\r\n                        // корабль находится в углу поля, там других кораблей нет\r\n                    } else {\r\n                        if (field[y][x].containsShip)\r\n                            return false;\r\n                    }\r\n                }\r\n\r\n            }\r\n            break;\r\n        default:\r\n    }\r\n    return true;\r\n}","// компонент, который создает и экспортирует стандартный набор кораблей\r\n// направление кораблю задается для того, чтобы можно было определить, в какую сторону его рисовать из стартовой точки\r\n// Размещать корабли можно либо вертикально, либо горизонтально, были выбраны направления вправо(right) и вниз(down), \r\n// поскольку они совпадают с положительными направлениеми координатных осей\r\n\r\nimport {getRandomInt} from './Common'\r\nimport placeShip from \"./placeShip\";\r\nimport checkPlaceShip from \"./checkPlaceShip\";\r\n\r\nclass Ship {\r\n    constructor(size, startSquare, direction) {\r\n        this.size = size;\r\n        this.startSquare = startSquare;\r\n        this.direction = direction;\r\n        this.id = Ship.incrementId();\r\n        this.hitpoints = this.size;\r\n    }\r\n\r\n    static incrementId() {\r\n        if (!this.latestId) {\r\n            this.latestId = 1;\r\n        } else {\r\n            this.latestId++;\r\n        }\r\n        return this.latestId\r\n    }\r\n}\r\n\r\n\r\nexport function placeVarious()\r\n{\r\n    let enemyField = [];\r\n\r\n    // первоначальное (пустое) состояние поля\r\n    for (let i = 0; i < 10; i++) {\r\n        enemyField.push([]);\r\n    }\r\n\r\n    for (let i = 0; i < 10; i++) {\r\n        for (let j = 0; j < 10; j++) {\r\n            enemyField[i].push({\r\n                x: j,\r\n                y: i,\r\n                containsShip: false,\r\n                shot: false,\r\n                isShipVisible: false,\r\n                shipId: null,\r\n            });\r\n        }\r\n    }\r\n\r\n\r\n    let variableSet = [];\r\n    // i-порядок расстановки (оно же количество короблей такой длины)\r\n    // и соответственно длина на каждом уровне  5-i\r\n    for (let i=1; i<=4; i++)\r\n    //for (let i=1; i<=1; i++)\r\n    {\r\n        for (let j=1; j<=i; j++)\r\n        {\r\n            // длина корабля\r\n            let l=5-i;\r\n            let ship, x, y;\r\n            for(;;) {\r\n                x = getRandomInt(1, 10 - l + 1);\r\n                y = getRandomInt(1, 10);\r\n\r\n                let direction=Math.random();\r\n                if (direction>= 0.5) {\r\n                    ship = new Ship(l, {y: y, x: x}, 'right');\r\n                } else {\r\n                    ship = new Ship(l, {y: x, x: y}, 'down');\r\n                }\r\n                if (checkPlaceShip(enemyField, ship))\r\n                   break;\r\n            }\r\n            placeShip(enemyField, ship);\r\n            variableSet.push(ship);\r\n        }\r\n\r\n    }\r\n    return variableSet;\r\n}\r\n\r\nexport default placeVarious;","import Constants from './constants';\r\nimport { codeCoordinate, decodeCoordinate} from './utils/Common';\r\n\r\nimport MyBoard from './components/my_board'\r\nimport OpponentBoard from './components/opponent_board';\r\n\r\nimport placeShip from './utils/placeShip';\r\nimport placeVarious from './utils/standardShipsSet';\r\n\r\nfunction getBoardInitialState()\r\n{\r\n  let initial_myField = Array(0);\r\n  let myShips = placeVarious();\r\n\r\n  let initial_enemyField = Array(0);\r\n  let enemyShips = placeVarious();\r\n\r\n\r\n  // первоначальное (пустое) состояние поля\r\n  //for (let i = 0; i < 10; i++) {\r\n  //  initial_myField.push([]);\r\n  //  initial_enemyField.push([]);\r\n  //}\r\n\r\n  for (let i = 0; i < 10; i++) {\r\n    let val_in_line = [];\r\n    let enemy_val_in_line = [];\r\n\r\n    for (let j = 0; j < 10; j++) {\r\n      val_in_line.push({\r\n        x: j,\r\n        y: i,\r\n        containsShip: false,\r\n        shot: false,\r\n        isShipVisible: false,\r\n        shipId: null,\r\n      });\r\n\r\n      enemy_val_in_line.push({\r\n        x: j,\r\n        y: i,\r\n        containsShip: false,\r\n        shot: false,\r\n        isShipVisible: false,\r\n        shipId: null,\r\n      });\r\n    }\r\n\r\n    initial_myField.push(val_in_line);\r\n    initial_enemyField.push(enemy_val_in_line);\r\n  }\r\n\r\n    // расставляем стандартный набор кораблей\r\n    myShips.forEach((ship: any) => {\r\n      placeShip(initial_myField, ship)\r\n    });\r\n    enemyShips.forEach((ship0: any) => {\r\n      placeShip(initial_enemyField, ship0)\r\n    });\r\n\r\n\r\n  let my_grid = [];\r\n  let enemy_grid = [];\r\n\r\n  // Заполняем из наших массивов\r\n  let remaining_hit_points = 0;\r\n  for (let y = 0; y < 10; y++) {\r\n    let my_line = [];\r\n    let enemy_line = [];\r\n    for (let x = 0; x < 10; x++) {\r\n      // Наши корабли\r\n      let fieldVal = initial_myField[y][x];\r\n      let fieldVal_0 = fieldVal.shot ? Constants.GRID_VALUE_WATER_HIT : Constants.GRID_VALUE_WATER;\r\n      if (fieldVal.containsShip)\r\n        fieldVal_0 = fieldVal.shot ? Constants.GRID_VALUE_SHIP_HIT : Constants.GRID_VALUE_SHIP;\r\n      my_line.push(fieldVal_0);\r\n      // Корабли оппонента\r\n      fieldVal = initial_enemyField[y][x];\r\n      fieldVal_0 = fieldVal.shot ? Constants.GRID_VALUE_WATER_HIT : Constants.GRID_VALUE_WATER;\r\n      if (fieldVal.containsShip) {\r\n        fieldVal_0 = fieldVal.shot ? Constants.GRID_VALUE_SHIP_HIT : Constants.GRID_VALUE_SHIP;\r\n        remaining_hit_points++;\r\n      }\r\n      enemy_line.push(fieldVal_0);\r\n    }\r\n\r\n    my_grid.push(my_line);\r\n    enemy_grid.push(enemy_line);\r\n\r\n  }\r\n\r\n  let initial_my_board = { grid: my_grid };\r\n  let initial_opponent_board = { grid: enemy_grid, remaining_hit_points};\r\n\r\n  return {\r\n    //notes: [],\r\n\r\n    my_board: initial_my_board,\r\n    myField: initial_myField,\r\n    opponent_board: initial_opponent_board,\r\n    enemyField: initial_enemyField\r\n    \r\n  };\r\n\r\n}\r\n\r\nfunction getFullInitialState()\r\n{\r\n  let boardInitialState=getBoardInitialState();\r\n  let state={\r\n    actionsToSend: [],\r\n    debugLastUserTalkCoord: \"\",\r\n\r\n\r\n    my_board: boardInitialState.my_board,\r\n    myField: boardInitialState.myField,\r\n    opponent_board: boardInitialState.opponent_board,\r\n    enemyField: boardInitialState.enemyField,\r\n    character: 'sber',\r\n    respectfulAppeal: true, \r\n    enemyTurnForce: 0,\r\n    enemyTurn: false, gameOver: false, youWin: false,\r\n    // TODO true, если надо сразу видеть\r\n    showHidden: false\r\n  };\r\n  return state;\r\n}\r\n\r\n\r\nconst emptyRow=[Constants.GRID_VALUE_WATER, Constants.GRID_VALUE_WATER, Constants.GRID_VALUE_WATER, Constants.GRID_VALUE_WATER, Constants.GRID_VALUE_WATER,\r\n  Constants.GRID_VALUE_WATER, Constants.GRID_VALUE_WATER, Constants.GRID_VALUE_WATER, Constants.GRID_VALUE_WATER, Constants.GRID_VALUE_WATER];\r\nconst emptyGrid=[emptyRow,emptyRow,emptyRow,emptyRow,emptyRow,emptyRow,emptyRow,emptyRow,emptyRow,emptyRow];\r\n\r\n// важно - тот же самый тип должен быть у getFullInitialState()\r\nexport const initialState = { actionsToSend: [], debugLastUserTalkCoord: \"\", my_board: {grid: emptyGrid}, myField: [], opponent_board: {grid: emptyGrid, remaining_hit_points:0}, enemyField: [],\r\n  character: 'sber',\r\n  respectfulAppeal: true, \r\n  enemyTurnForce: 0,\r\n  enemyTurn: false, gameOver: false, youWin: false,\r\n  showHidden: false\r\n};\r\n\r\n\r\n/*\r\ntype Note = {\r\n  id: string;\r\n  title: string;\r\n  completed: boolean;\r\n};\r\n*/\r\n\r\ntype ActionToSend = {\r\n  id: string;\r\n  Action: { action: any };\r\n}\r\n\r\ntype State = {\r\n  //notes: Array<Note>;\r\n  actionsToSend: Array<ActionToSend>,\r\n  debugLastUserTalkCoord: string,\r\n\r\n  my_board: { grid: string[][]},\r\n  myField: any[],\r\n  opponent_board: { grid: string[][], remaining_hit_points: number},\r\n  enemyField: any[],\r\n\r\n  character: string,\r\n  respectfulAppeal: boolean, \r\n  enemyTurnForce: number, enemyTurn: boolean, gameOver: boolean, youWin: boolean,\r\n  showHidden: boolean\r\n};\r\n\r\ntype Action =\r\n  | {\r\n    type: \"init\";\r\n  }\r\n  | {\r\n    type: \"show_ships\";\r\n  }\r\n  | {\r\n    type: \"character\";\r\n    character_id: string;\r\n    }\r\n  | {\r\n    type: \"game_over_lost\";\r\n    }\r\n  | {\r\n    type: \"game_replay\";\r\n    }\r\n  | {\r\n    type: \"clear_action\";\r\n    id: string;\r\n    }\r\n  | {\r\n    type: \"enemy_fire\";\r\n    coord_str: string;\r\n  }\r\n  | {\r\n    type: \"lets_fire\";\r\n    coord_str: string;\r\n  };\r\n\r\n  /*\r\n  | {\r\n      type: \"add_note\";\r\n      note: string;\r\n    }\r\n  | {\r\n      type: \"done_note\";\r\n      id: string;\r\n    }\r\n  | {\r\n      type: \"delete_note\";\r\n      id: string;\r\n    };\r\n    */\r\n\r\nexport const reducer = (state: State, action: Action) => {\r\n\r\n  switch (action.type) {\r\n      /*\r\n    case \"init\":\r\n      let initial_myField = Array(0);\r\n      let myShips = placeVarious();\r\n    \r\n      let initial_enemyField = Array(0);\r\n      let enemyShips = placeVarious();\r\n    \r\n    \r\n      // первоначальное (пустое) состояние поля\r\n      //for (let i = 0; i < 10; i++) {\r\n      //  initial_myField.push([]);\r\n      //  initial_enemyField.push([]);\r\n      //}\r\n    \r\n      for (let i = 0; i < 10; i++) {\r\n        let val_in_line = [];\r\n        let enemy_val_in_line = [];\r\n    \r\n        for (let j = 0; j < 10; j++) {\r\n          val_in_line.push({\r\n            x: j,\r\n            y: i,\r\n            containsShip: false,\r\n            shot: false,\r\n            isShipVisible: false,\r\n            shipId: null,\r\n          });\r\n    \r\n          enemy_val_in_line.push({\r\n            x: j,\r\n            y: i,\r\n            containsShip: false,\r\n            shot: false,\r\n            isShipVisible: false,\r\n            shipId: null,\r\n          });\r\n        }\r\n    \r\n        initial_myField.push(val_in_line);\r\n        initial_enemyField.push(enemy_val_in_line);\r\n      }\r\n    \r\n        // расставляем стандартный набор кораблей\r\n        myShips.forEach((ship: any) => {\r\n          placeShip(initial_myField, ship)\r\n        });\r\n        enemyShips.forEach((ship0: any) => {\r\n          placeShip(initial_enemyField, ship0)\r\n        });\r\n    \r\n    \r\n      let my_grid = [];\r\n      let enemy_grid = [];\r\n    \r\n      // Заполняем из наших массивов\r\n      let remaining_hit_points = 0;\r\n      for (let y = 0; y < 10; y++) {\r\n        let my_line = [];\r\n        let enemy_line = [];\r\n        for (let x = 0; x < 10; x++) {\r\n          // Наши корабли\r\n          let fieldVal = initial_myField[y][x];\r\n          let fieldVal_0 = fieldVal.shot ? Constants.GRID_VALUE_WATER_HIT : Constants.GRID_VALUE_WATER;\r\n          if (fieldVal.containsShip)\r\n            fieldVal_0 = fieldVal.shot ? Constants.GRID_VALUE_SHIP_HIT : Constants.GRID_VALUE_SHIP;\r\n          my_line.push(fieldVal_0);\r\n          // Корабли оппонента\r\n          fieldVal = initial_enemyField[y][x];\r\n          fieldVal_0 = fieldVal.shot ? Constants.GRID_VALUE_WATER_HIT : Constants.GRID_VALUE_WATER;\r\n          if (fieldVal.containsShip) {\r\n            fieldVal_0 = fieldVal.shot ? Constants.GRID_VALUE_SHIP_HIT : Constants.GRID_VALUE_SHIP;\r\n            remaining_hit_points++;\r\n          }\r\n          enemy_line.push(fieldVal_0);\r\n        }\r\n    \r\n        my_grid.push(my_line);\r\n        enemy_grid.push(enemy_line);\r\n    \r\n      }\r\n    \r\n      let initial_my_board = { grid: my_grid };\r\n      let initial_opponent_board = { grid: enemy_grid, remaining_hit_points};\r\n    \r\n      return {\r\n        notes: [],\r\n        my_board: initial_my_board,\r\n        myField: initial_myField,\r\n        opponent_board: initial_opponent_board,\r\n        enemyField: initial_enemyField\r\n      };\r\n      */\r\n\r\n    case \"init\":\r\n      return getFullInitialState();\r\n\r\n\r\n    case \"character\":\r\n      return {\r\n        ...state,\r\n        character: action.character_id, respectfulAppeal: action.character_id!=='joy'\r\n      }\r\n  \r\n    case \"show_ships\":\r\n      return {\r\n        ...state,\r\n        showHidden: true\r\n      }\r\n\r\n    case \"game_over_lost\":\r\n      return {\r\n        ...state,\r\n        gameOver: true, youWin: false\r\n      }\r\n\r\n    case \"game_replay\":\r\n      return {\r\n        ...getFullInitialState(),\r\n        character: state.character,\r\n        respectfulAppeal: state.respectfulAppeal\r\n      }\r\n\r\n    case \"clear_action\":\r\n      return {\r\n        ...state,\r\n        actionsToSend: []\r\n      }\r\n\r\n    case \"enemy_fire\":\r\n    {\r\n      let actionsToSend=state.actionsToSend.slice();\r\n\r\n      let fire_registered=false;\r\n      let coord=decodeCoordinate(action.coord_str);\r\n      if (coord)\r\n      {\r\n        let x=coord.x, y=coord.y;\r\n\r\n        let field=state.myField[y][x];\r\n        if (field.containsShip)\r\n        {\r\n          // Попали в корабль\r\n          if (!field.shot)\r\n          {\r\n            // До этого в это поле не попадали\r\n            fire_registered=true;\r\n            let newMyField=state.myField.slice();\r\n            newMyField[y]=newMyField[y].slice();\r\n            newMyField[y][x]={...newMyField[y][x], shot:true};\r\n            let shipId=field.shipId;\r\n            // Проверим, есть ли еще не подбитые его части\r\n            let live_parts=0;\r\n            for (let y = 0; y < 10; y++) {\r\n              for (let x = 0; x < 10; x++) {\r\n                if (newMyField[y][x].containsShip && newMyField[y][x].shipId===shipId)\r\n                {\r\n                  if (!newMyField[y][x].shot)\r\n                    live_parts++;\r\n                }\r\n              }\r\n            }\r\n            // TODO если корабль полностью подбит, рисовать его как-то по-другому\r\n        \r\n            let grid=state.my_board.grid.slice();\r\n            grid[y]=state.my_board.grid[y].slice();\r\n            grid[y][x] = Constants.GRID_VALUE_SHIP_HIT;\r\n            if (live_parts>0)\r\n              actionsToSend.push({id:'0', Action: { action: { action_id: 'enemy_fire_hit', parameters: { coord: action.coord_str} } }});\r\n            else\r\n              actionsToSend.push({id:'0', Action: { action: { action_id: 'enemy_fire_down', parameters: { coord: action.coord_str} } }});\r\n\r\n            // посчитаем, сколько у игрока осталось кораблей\r\n            let playerLivesCount=0;\r\n            for (let y = 0; y < 10; y++) {\r\n              for (let x = 0; x < 10; x++) {\r\n                // если туда еще не стреляли\r\n                if (!newMyField[y][x].shot&&newMyField[y][x].containsShip)\r\n                  playerLivesCount++;\r\n              }\r\n            }\r\n           \r\n            if (playerLivesCount>0)\r\n            {\r\n              // TODO еще один выстрел\r\n            //  setTimeout(() => processEnemyMove(), 1200);\r\n\r\n              // просто очередное попадание, ход не переходит\r\n              return {...state,\r\n                my_board: {grid: grid},\r\n                myField: newMyField,\r\n                actionsToSend: actionsToSend,\r\n                // а это сделано для того, чтобы вызвалась проверка enemyTurn\r\n                enemyTurnForce: state.enemyTurnForce+1\r\n                }\r\n  \r\n            } else\r\n            {\r\n              // Игра окончена\r\n              //setAppState({...appState, gameOver: true, youWin: false});\r\n              actionsToSend.push({id:'0', Action: { action: { action_id: 'gameOverLost', parameters: {} } }});\r\n              // игрок выиграл\r\n              return {...state,\r\n                my_board: {grid: grid},\r\n                myField: newMyField,\r\n                gameOver: true,\r\n                youWin: false,\r\n                actionsToSend: actionsToSend\r\n                }\r\n            }\r\n\r\n          } else {\r\n            // Повторное попадание. Ход считаем, что не переходит\r\n            //actionsToSend.push({id:'0', Action: { action: { action_id: 'fireAgain', parameters: { coord: action.coord_str} } }});\r\n          }\r\n        } else {\r\n          actionsToSend.push({id:'0', Action: { action: { action_id: 'enemy_fire_miss', parameters: { coord: action.coord_str} } }});\r\n          // Попали в воду\r\n          let grid=state.my_board.grid.slice();\r\n          grid[y]=state.my_board.grid[y].slice();\r\n          if (grid[y][x] === Constants.GRID_VALUE_WATER)\r\n          {\r\n            // До этого туда не стреляли\r\n            fire_registered=true;\r\n            // хотя это бы и не обязательно делать (заполнять enemyField для воды), все равно попадание у нас контролируется по-другому,\r\n            // но для корректности данных лучше так сделать\r\n            let newMyField=state.myField.slice();\r\n            newMyField[y]=newMyField[y].slice();\r\n            newMyField[y][x]={...newMyField[y][x], shot:true};\r\n            //\r\n            grid[y][x] = Constants.GRID_VALUE_WATER_HIT;\r\n            //this.setState({ enemyField: newEnemyField, opponent_board: { ...this.state.opponent_board, grid: grid} });\r\n            return {...state,\r\n              my_board: { ...state.my_board, grid: grid}, myField: newMyField,\r\n              enemyTurn: false,\r\n              actionsToSend: actionsToSend\r\n            }\r\n          }\r\n        }\r\n      }\r\n  \r\n      return {\r\n        ...state,\r\n        actionsToSend: actionsToSend\r\n      }\r\n    }\r\n\r\n    case \"lets_fire\":\r\n    {\r\n      let actionsToSend=state.actionsToSend.slice();\r\n      if (state.enemyTurn)\r\n      {\r\n        // тут про сессии можно почитать\r\n        // https://developer.sberdevices.ru/docs/ru/developer_tools/ide/JS_API/session_lifetime_control\r\n        actionsToSend.push({id:'0', Action: { action: { action_id: 'myMove'} }});\r\n        // и на всякий случай защита от зависания таймера\r\n        return {\r\n          ...state,\r\n          actionsToSend: actionsToSend,\r\n          enemyTurnForce: state.enemyTurnForce+1\r\n        }\r\n        \r\n      } else\r\n      {\r\n        //alert(myAction.coord_str);\r\n        let fire_registered=false;\r\n        let coord=decodeCoordinate(action.coord_str);\r\n        if (coord)\r\n        {\r\n          let x=coord.x, y=coord.y;\r\n  \r\n          let field=state.enemyField[y][x];\r\n          if (field.containsShip)\r\n          {\r\n            // Попали в корабль\r\n            if (!field.shot)\r\n            {\r\n              // До этого в это поле не попадали\r\n              fire_registered=true;\r\n              let newEnemyField=state.enemyField.slice();\r\n              newEnemyField[y]=newEnemyField[y].slice();\r\n              newEnemyField[y][x]={...newEnemyField[y][x], shot:true};\r\n              let shipId=field.shipId;\r\n              // Проверим, есть ли еще не подбитые его части\r\n              let live_parts=0;\r\n              for (let y = 0; y < 10; y++) {\r\n                for (let x = 0; x < 10; x++) {\r\n                  if (newEnemyField[y][x].containsShip && newEnemyField[y][x].shipId===shipId)\r\n                  {\r\n                    if (!newEnemyField[y][x].shot)\r\n                      live_parts++;\r\n                  }\r\n                }\r\n              }\r\n              // TODO если корабль полностью подбит, рисовать его как-то по-другому\r\n          \r\n              let grid=state.opponent_board.grid.slice();\r\n              grid[y]=state.opponent_board.grid[y].slice();\r\n              grid[y][x] = Constants.GRID_VALUE_SHIP_HIT;\r\n              if (live_parts>0)\r\n                actionsToSend.push({id:'0', Action: { action: { action_id: 'fireHit', parameters: { coord: action.coord_str} } }});\r\n              else\r\n                actionsToSend.push({id:'0', Action: { action: { action_id: 'fireDone', parameters: { coord: action.coord_str} } }});\r\n              if (state.opponent_board.remaining_hit_points<=1)\r\n              {\r\n                actionsToSend.push({id:'0', Action: { action: { action_id: 'gameOverWin', parameters: {} } }});\r\n                // игрок выиграл\r\n                return {...state,\r\n                  opponent_board: {grid: grid, remaining_hit_points: state.opponent_board.remaining_hit_points-1},\r\n                  enemyField: newEnemyField,\r\n                  gameOver: true,\r\n                  youWin: true,\r\n                  actionsToSend: actionsToSend\r\n                  }\r\n              } else {\r\n                // просто очередное попадание, ход не переходит\r\n                return {...state,\r\n                opponent_board: {grid: grid, remaining_hit_points: state.opponent_board.remaining_hit_points-1},\r\n                enemyField: newEnemyField,\r\n                actionsToSend: actionsToSend,\r\n                debugLastUserTalkCoord: action.coord_str                \r\n                }\r\n              }\r\n  \r\n            } else {\r\n              // Повторное попадание. Ход считаем, что не переходит\r\n              actionsToSend.push({id:'0', Action: { action: { action_id: 'fireAgain', parameters: { coord: action.coord_str} } }});\r\n            }\r\n          } else {\r\n            // Попали в воду\r\n            let grid=state.opponent_board.grid.slice();\r\n            grid[y]=state.opponent_board.grid[y].slice();\r\n            if (grid[y][x] === Constants.GRID_VALUE_WATER)\r\n            {\r\n              // До этого туда не стреляли\r\n              fire_registered=true;\r\n              // хотя это бы и не обязательно делать (заполнять enemyField для воды), все равно попадание у нас контролируется по-другому,\r\n              // но для корректности данных лучше так сделать\r\n              let newEnemyField=state.enemyField.slice();\r\n              newEnemyField[y]=newEnemyField[y].slice();\r\n              newEnemyField[y][x]={...newEnemyField[y][x], shot:true};\r\n              //\r\n              grid[y][x] = Constants.GRID_VALUE_WATER_HIT;\r\n              //this.setState({ enemyField: newEnemyField, opponent_board: { ...this.state.opponent_board, grid: grid} });\r\n              actionsToSend.push({id:'0', Action: { action: { action_id: 'fireMiss', parameters: { coord: action.coord_str} } }});\r\n\r\n              return {...state,\r\n                actionsToSend: actionsToSend,\r\n                debugLastUserTalkCoord: action.coord_str,\r\n                opponent_board: { ...state.opponent_board, grid: grid}, enemyField: newEnemyField,\r\n                enemyTurn: true\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n      return {\r\n        ...state,\r\n        actionsToSend: actionsToSend,\r\n        debugLastUserTalkCoord: action.coord_str\r\n      }\r\n    }\r\n      \r\n  \r\n\r\n      /*\r\n      let fire_registered=false;\r\n      let coord=decodeCoordinate(action.coord_str);\r\n      if (coord)\r\n      {\r\n        let x=coord.x, y=coord.y;\r\n\r\n        let field=state.enemyField[y][x];\r\n        if (field.containsShip)\r\n        {\r\n          // Попали в корабль\r\n          if (!field.shot)\r\n          {\r\n            // До этого в это поле не попадали\r\n            fire_registered=true;\r\n            let newEnemyField=state.enemyField.slice();\r\n            newEnemyField[y][x].shot=true;\r\n            let shipId=field.shipId;\r\n            // Проверим, есть ли еще не подбитые его части\r\n            let live_parts=0;\r\n            for (let y = 0; y < 10; y++) {\r\n              for (let x = 0; x < 10; x++) {\r\n                if (newEnemyField[y][x].containsShip && newEnemyField[y][x].shipId===shipId)\r\n                {\r\n                  if (!newEnemyField[y][x].shot)\r\n                    live_parts++;\r\n                }\r\n              }\r\n            }\r\n            // TODO если корабль полностью подбит, рисовать его как-то по-другому\r\n        \r\n            let grid=state.opponent_board.grid.slice();\r\n            grid[y][x] = Constants.GRID_VALUE_SHIP_HIT;\r\n            //setState({ enemyField: newEnemyField, opponent_board: { ...appState.opponent_board, grid: grid, remaining_hit_points: remaining_hit_points} });\r\n            let newState={...state,\r\n            opponent_board: {grid: grid, remaining_hit_points: state.opponent_board.remaining_hit_points-1},\r\n            enemyField: newEnemyField\r\n            };\r\n            return newState;\r\n          } else {\r\n            // Повторное попадание\r\n          }\r\n        } else {\r\n          // Попали в воду\r\n          let grid=state.opponent_board.grid.slice();\r\n          if (grid[y][x] === Constants.GRID_VALUE_WATER)\r\n          {\r\n            // До этого туда не стреляли\r\n            fire_registered=true;\r\n            // хотя это бы и не обязательно делать (заполнять enemyField для воды), все равно попадание у нас контролируется по-другому,\r\n            // но для корректности данных лучше так сделать\r\n            let newEnemyField=state.enemyField.slice();\r\n            newEnemyField[y][x].shot=true;\r\n            //\r\n            grid[y][x] = Constants.GRID_VALUE_WATER_HIT;\r\n            //this.setState({ enemyField: newEnemyField, opponent_board: { ...this.state.opponent_board, grid: grid} });\r\n            return {\r\n              ...state,\r\n              opponent_board: { ...state.opponent_board, grid: grid}, enemyField: newEnemyField\r\n            };\r\n      \r\n          }\r\n        }\r\n      }\r\n      return {\r\n        ...state,     \r\n      }\r\n      */\r\n      \r\n/* \r\n      let grid=state.opponent_board.grid.slice();\r\n      grid[0][0] = Constants.GRID_VALUE_SHIP_HIT;\r\n      let remaining_hit_points = state.opponent_board.remaining_hit_points;\r\n      remaining_hit_points = remaining_hit_points - 1;\r\n      return {\r\n        ...state,\r\n        opponent_board: { grid: grid, remaining_hit_points: remaining_hit_points }\r\n      };\r\n     case \"add_note\":\r\n      return {\r\n        ...state,\r\n        notes: [\r\n          ...state.notes,\r\n          {\r\n            id: Math.random().toString(36).substring(7),\r\n            title: action.note,\r\n            completed: false,\r\n          },\r\n        ],\r\n      };\r\n\r\n    case \"done_note\":\r\n      return {\r\n        ...state,\r\n        notes: state.notes.map((note) =>\r\n          note.id === action.id ? { ...note, completed: !note.completed } : note\r\n        ),\r\n      };\r\n\r\n    case \"delete_note\":\r\n      return {\r\n        ...state,\r\n        notes: state.notes.filter(({ id }) => id !== action.id),\r\n      };\r\n      */\r\n\r\n    default:\r\n      throw new Error();\r\n  }\r\n};\r\n","import React, {\r\n  FC,\r\n  memo,\r\n  useReducer,\r\n  useState,\r\n  useRef,\r\n  useEffect,\r\n  useLayoutEffect,\r\n  RefObject,\r\n} from 'react';\r\n\r\nimport {\r\n  createSmartappDebugger,\r\n  createAssistant,\r\n  AssistantAppState,\r\n  AssistantSmartAppData,\r\n  AssistantCharacterType\r\n} from \"@sberdevices/assistant-client\";\r\n\r\n//import  {Link} from 'react-router-dom';\r\n\r\nimport Constants from './constants';\r\nimport Header from './components/header'\r\nimport Chat from './components/chat'\r\nimport MyBoard from './components/my_board'\r\nimport OpponentBoard from './components/opponent_board';\r\n\r\nimport placeShip from './utils/placeShip';\r\nimport placeVarious from './utils/standardShipsSet';\r\n\r\n\r\n// Это не обязательно, т.к. все в в index на самом деле\r\n//import './App.css';\r\n\r\nimport { getRandomInt, codeCoordinate, decodeCoordinate} from './utils/Common';\r\nimport { initialState, reducer } from \"./store\";\r\n\r\n// createGlobalStyle нужен для создания глобальных стилей\r\nimport styled, { createGlobalStyle, css } from 'styled-components';\r\n\r\n// получаем значение для целевой платформы\r\nimport { sberBox } from '@sberdevices/plasma-tokens/typo';\r\n// получаем стилевые объекты для нашего интерфейса\r\nimport { body1, headline2 } from '@sberdevices/plasma-tokens';\r\n\r\n// получаем тему персонажа\r\nimport { darkEva, darkSber, darkJoy } from '@sberdevices/plasma-tokens/themes';\r\n\r\n// получаем цвета для нашего интерфейса\r\nimport { text, background, gradient } from '@sberdevices/plasma-tokens';\r\n\r\nimport { Button } from '@sberdevices/ui';\r\nimport { createArrayTypeNode } from 'typescript';\r\n\r\n//import { IconDownload } from '@sberdevices/plasma-icons';\r\n\r\n\r\n\r\nconst AppStyled = styled.div`\r\n    padding: 30px;\r\n    ${body1}\r\n`;\r\n\r\n// создаем react-компонент c глобальными стилями типографики\r\nconst TypoScale = createGlobalStyle(sberBox);\r\n\r\n// создаем react-компонент для подложки\r\nconst DocStyles = createGlobalStyle`\r\n    /* stylelint-disable-next-line selector-nested-pattern */\r\n    html {\r\n        color: ${text};\r\n        background-color: ${background};\r\n        background-image: ${gradient};\r\n\r\n        /** необходимо залить градиентом всю подложку */\r\n        min-height: 100vh;\r\n    }\r\n`;\r\n// создаем react-компонент для персонажа\r\n//const Theme = createGlobalStyle(darkJoy);\r\n//const Theme = createGlobalStyle(lightJoy);\r\n\r\nconst ThemeBackgroundEva = createGlobalStyle(darkEva);\r\nconst ThemeBackgroundSber = createGlobalStyle(darkSber);\r\nconst ThemeBackgroundJoy = createGlobalStyle(darkJoy);\r\n\r\n// Плазма\r\n//https://plasma.sberdevices.ru/current/?path=/docs/about--page\r\n\r\n\r\nconst initializeAssistant = (getState: any) => {\r\n  console.log('process.env.NODE_ENV=');\r\n  console.log(process.env.NODE_ENV);\r\n  if (process.env.NODE_ENV === \"development\") {\r\n    return createSmartappDebugger({\r\n      token: process.env.REACT_APP_TOKEN ?? \"\",\r\n      initPhrase: `Запусти ${process.env.REACT_APP_SMARTAPP}`,\r\n      getState,\r\n    });\r\n  }\r\n\r\n  return createAssistant({ getState });\r\n};\r\n\r\n\r\nexport const App: FC = memo(() => {\r\n  const [appState, dispatch] = useReducer(reducer, initialState);\r\n  //const [note, setNote] = useState(\"\");\r\n  //const [appState, setAppState] = useState(constFullInitialState);\r\n\r\n  const assistantStateRef = useRef<AssistantAppState>();\r\n  const assistantRef = useRef<ReturnType<typeof createAssistant>>();\r\n\r\n  useEffect(() => {\r\n\r\n    dispatch({type: 'init'});\r\n\r\n    assistantRef.current = initializeAssistant(() => assistantStateRef.current);\r\n\r\n    assistantRef.current.on(\"data\", ({ type, character, navigation, action }: any) => {\r\n      // Из-за того, что React.Strict несмотря на то, что вызов я делаю 1 раз, dispatch срабатывае дважды\r\n      // поэтому сделаем счетчик\r\n      if (character)\r\n      {\r\n        // TODO брать respectfulAppeal из character\r\n        // 'sber' | 'eva' | 'joy';\r\n        //setAppState({...appState, character: character.id, respectfulAppeal: character.id!=='joy'});\r\n        dispatch({type: 'character', character_id: character.id});\r\n      }\r\n      // Где-то он и без меня вызывается, поэтому здесь убрал\r\n      if (action) {\r\n        dispatch(action);\r\n      }\r\n    });\r\n  }, []);\r\n\r\n  useEffect(() => {\r\n    assistantStateRef.current = {\r\n      gameOver: appState.gameOver\r\n      /*\r\n      item_selector: {\r\n        items: appState.notes.map(({ id, title }, index) => ({\r\n          number: index + 1,\r\n          id,\r\n          title,\r\n        })),\r\n      },\r\n        */\r\n    };\r\n  }, [appState.gameOver]);\r\n\r\n  useEffect(() => {\r\n    //assistantRef.current?.sendData({ action: { action_id: 'myMove'} });\r\n    if (appState.actionsToSend.length>0)\r\n    {\r\n      appState.actionsToSend.forEach(element => {\r\n        assistantRef.current?.sendData(element.Action);\r\n      });\r\n      dispatch({type: 'clear_action', id: '0'});\r\n    }\r\n  }, [appState.actionsToSend]);\r\n\r\n  useEffect(() => {\r\n    if (appState.enemyTurn)\r\n    {\r\n      // TODO тест передаем ход игроку\r\n      //setAppState({...appState, enemyTurn: false});\r\n      setTimeout(() => processEnemyMove(), 1200);\r\n    }\r\n  }, [appState.enemyTurn, appState.enemyTurnForce]);\r\n\r\n\r\n\r\n\r\n/*\r\n  // { type: \"lets_fire\", coord_str: codeCoordinate(x,y)})\r\n  function myDispatch(myAction: any)\r\n  {\r\n\r\n    if (myAction.type==='show_ships')\r\n    {\r\n      setAppState({...appState, showHidden: true});\r\n    }\r\n\r\n    if (myAction.type==='game_over_lost')\r\n    {\r\n      setAppState({...appState, gameOver: true, youWin: false\r\n      });\r\n    }\r\n\r\n    if (myAction.type==='game_replay')\r\n    {\r\n      // тот же код, что при иннициализации\r\n      // кроме установки персонажа\r\n      let newAppState=getFullInitialState();\r\n      newAppState.character=appState.character;\r\n      newAppState.respectfulAppeal=appState.respectfulAppeal;\r\n      setAppState(newAppState);\r\n    }\r\n\r\n\r\n    if (myAction.type==='lets_fire')\r\n    if (appState.enemyTurn)\r\n    {\r\n      // тут про сессии можно почитать\r\n      // https://developer.sberdevices.ru/docs/ru/developer_tools/ide/JS_API/session_lifetime_control\r\n      assistantRef.current?.sendData({ action: { action_id: 'myMove'} });\r\n    } else\r\n    {\r\n      //alert(myAction.coord_str);\r\n      let fire_registered=false;\r\n      let coord=decodeCoordinate(myAction.coord_str);\r\n      if (coord)\r\n      {\r\n        let x=coord.x, y=coord.y;\r\n\r\n        let field=appState.enemyField[y][x];\r\n        if (field.containsShip)\r\n        {\r\n          // Попали в корабль\r\n          if (!field.shot)\r\n          {\r\n            // До этого в это поле не попадали\r\n            fire_registered=true;\r\n            let newEnemyField=appState.enemyField.slice();\r\n            newEnemyField[y][x].shot=true;\r\n            let shipId=field.shipId;\r\n            // Проверим, есть ли еще не подбитые его части\r\n            let live_parts=0;\r\n            for (let y = 0; y < 10; y++) {\r\n              for (let x = 0; x < 10; x++) {\r\n                if (newEnemyField[y][x].containsShip && newEnemyField[y][x].shipId===shipId)\r\n                {\r\n                  if (!newEnemyField[y][x].shot)\r\n                    live_parts++;\r\n                }\r\n              }\r\n            }\r\n            // TODO если корабль полностью подбит, рисовать его как-то по-другому\r\n        \r\n            let grid=appState.opponent_board.grid.slice();\r\n            grid[y][x] = Constants.GRID_VALUE_SHIP_HIT;\r\n            //setState({ enemyField: newEnemyField, opponent_board: { ...appState.opponent_board, grid: grid, remaining_hit_points: remaining_hit_points} });\r\n            if (live_parts>0)\r\n              assistantRef.current?.sendData({ action: { action_id: 'fireHit', parameters: { coord: myAction.coord_str} } });\r\n            else\r\n            assistantRef.current?.sendData({ action: { action_id: 'fireDone', parameters: { coord: myAction.coord_str} } });\r\n            if (appState.opponent_board.remaining_hit_points<=1)\r\n            {\r\n              // игрок выиграл\r\n              setAppState({...appState,\r\n                opponent_board: {grid: grid, remaining_hit_points: appState.opponent_board.remaining_hit_points-1},\r\n                enemyField: newEnemyField,\r\n                gameOver: true,\r\n                youWin: true\r\n                });\r\n                assistantRef.current?.sendData({ action: { action_id: 'gameOverWin', parameters: {} } });\r\n            } else {\r\n              // просто очередное попадание, ход не переходит\r\n              setAppState({...appState,\r\n              opponent_board: {grid: grid, remaining_hit_points: appState.opponent_board.remaining_hit_points-1},\r\n              enemyField: newEnemyField\r\n              });\r\n            }\r\n\r\n          } else {\r\n            // Повторное попадание. Ход считаем, что не переходит\r\n            assistantRef.current?.sendData({ action: { action_id: 'fireAgain', parameters: { coord: myAction.coord_str} } });\r\n          }\r\n        } else {\r\n          // Попали в воду\r\n          let grid=appState.opponent_board.grid.slice();\r\n          if (grid[y][x] === Constants.GRID_VALUE_WATER)\r\n          {\r\n            // До этого туда не стреляли\r\n            fire_registered=true;\r\n            // хотя это бы и не обязательно делать (заполнять enemyField для воды), все равно попадание у нас контролируется по-другому,\r\n            // но для корректности данных лучше так сделать\r\n            let newEnemyField=appState.enemyField.slice();\r\n            newEnemyField[y][x].shot=true;\r\n            //\r\n            grid[y][x] = Constants.GRID_VALUE_WATER_HIT;\r\n            //this.setState({ enemyField: newEnemyField, opponent_board: { ...this.state.opponent_board, grid: grid} });\r\n            setAppState({...appState,\r\n              opponent_board: { ...appState.opponent_board, grid: grid}, enemyField: newEnemyField,\r\n              enemyTurn: true\r\n            });\r\n          }\r\n          assistantRef.current?.sendData({ action: { action_id: 'fireMiss', parameters: { coord: myAction.coord_str} } });\r\n        }\r\n      }\r\n\r\n      // Теперь он сам стреляет\r\n      // (сделано специально, чтобы в любом случае произошла проверка, чтобы игровой процесс не остановился по какой-нибудь причине)\r\n      //setTimeout(() => processEnemyMove(), 1200);\r\n\r\n    }\r\n  }\r\n\r\n  // вернет true, если оппонент попал\r\n  // в этом случае ход не переходит\r\n  function fireMyBoard(alphabetical_coord: string)\r\n  {\r\n    const coordinate=decodeCoordinate(alphabetical_coord);\r\n    if (coordinate==null)\r\n      return false;\r\n    const x=coordinate.x;\r\n    const y=coordinate.y;\r\n\r\n    let fire_registered=false;\r\n\r\n    let field=appState.myField[y][x];\r\n    if (field.containsShip)\r\n    {\r\n      // Попали в корабль\r\n      if (!field.shot)\r\n      {\r\n        // До этого в это поле не попадали\r\n        fire_registered=true;\r\n        let newEnemyField=appState.myField.slice();\r\n        newEnemyField[y][x].shot=true;\r\n        let shipId=field.shipId;\r\n        // Проверим, есть ли еще не подбитые его части\r\n        let live_parts=0;\r\n        for (let y = 0; y < 10; y++) {\r\n          for (let x = 0; x < 10; x++) {\r\n            if (newEnemyField[y][x].containsShip && newEnemyField[y][x].shipId===shipId)\r\n            {\r\n              if (!newEnemyField[y][x].shot)\r\n                live_parts++;\r\n            }\r\n          }\r\n        }\r\n        // TODO если корабль полностью подбит, рисовать его как-то по-другому\r\n    \r\n        let grid=appState.my_board.grid.slice();\r\n        grid[y][x] = Constants.GRID_VALUE_SHIP_HIT;\r\n        setAppState({...appState, myField: newEnemyField, my_board: { ...appState.my_board, grid: grid} });\r\n        return true;\r\n      } else {\r\n        // Повторное попадание\r\n      }\r\n    } else {\r\n      // Попали в воду\r\n      let grid=appState.my_board.grid.slice();\r\n      if (grid[y][x] === Constants.GRID_VALUE_WATER)\r\n      {\r\n        // До этого туда не стреляли\r\n        fire_registered=true;\r\n        let newEnemyField=appState.myField.slice();\r\n        newEnemyField[y][x].shot=true;\r\n        grid[y][x] = Constants.GRID_VALUE_WATER_HIT;\r\n        setAppState({...appState, myField: newEnemyField, my_board: { ...appState.my_board, grid: grid} });\r\n      }\r\n    }\r\n    return false;\r\n\r\n  }\r\n  */\r\n\r\n  function processEnemyMove()\r\n  {\r\n    // только в свой ход\r\n    if (!appState.enemyTurn)\r\n      return;\r\n\r\n    const offsets=[{x:-1,y:-1}, {x:0,y:-1}, {x:1,y:-1},\r\n      {x:-1,y:0}, {x:0,y:0}, {x:1,y:0},\r\n      {x:-1,y:1}, {x:0,y:1}, {x:1,y:1},\r\n    ];\r\n\r\n    const offsets4=[{x:0,y:-1},{x:-1,y:0},{x:1,y:0},{x:0,y:1}];\r\n\r\n    let field=appState.myField;\r\n    // Первый проход, ищем точки, где рядом есть с попаданиями\r\n    // они будут иметь признак первичных\r\n    // а уже на втором проходе будет происходить поиск, куда можно в принципе выстрелить\r\n    // поэтому если координата будет иметь признак первичной, но стрелять туда нельзя, она в массив не попадет\r\n    let primary_area=Array.from(Array(10), _ => Array(10).fill(0));\r\n    // если в этой координате подбитый корабль\r\n    // найдем, есть ли не подбитые в 4-х направлениях от него\r\n    // и если есть, то это он сам (т.к. нельзя ставить рядом)\r\n    // Заодно заполним список живых кораблей\r\n    let live_ships=new Set();\r\n    for (let y = 0; y < 10; y++) {\r\n      for (let x = 0; x < 10; x++) {\r\n        for (let i=0; i<offsets4.length; i++){\r\n          if (field[y][x].containsShip&&!field[y][x].shot) {\r\n            live_ships.add(field[y][x].shipId);\r\n          }\r\n          let _x=x+offsets4[i].x;\r\n          let _y=y+offsets4[i].y;\r\n          if (_x>=0&&_x<10&&_y>=0&&_y<10&&field[_y][_x].containsShip&&field[_y][_x].shot)\r\n          {\r\n            primary_area[y][x]=1;\r\n            break;\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    let primary_targets=[];\r\n    let targets=[];\r\n\r\n    // составим массив координат, куда враг может выстрелить\r\n    for (let y = 0; y < 10; y++) {\r\n      for (let x = 0; x < 10; x++) {\r\n        // если туда еще не стреляли\r\n        let canFire=true;\r\n        if (!field[y][x].shot)\r\n        {\r\n          // и вблизи нет подбитых (полностью) кораблей\r\n          for (let i=0; i<offsets.length; i++){\r\n            let _x=x+offsets[i].x;\r\n            let _y=y+offsets[i].y;\r\n            if (_x>=0&&_x<10&&_y>=0&&_y<10&&field[_y][_x].containsShip&&field[_y][_x].shot)\r\n            {\r\n              if (!live_ships.has(field[_y][_x].shipId))\r\n              {\r\n                canFire=false;\r\n                break;\r\n              }\r\n            }\r\n          }\r\n          if (canFire)\r\n          {\r\n            targets.push({y:y, x:x});\r\n            if (primary_area[y][x]===1)\r\n              primary_targets.push({y:y, x:x});\r\n          }\r\n        }\r\n      }\r\n    }\r\n    // На всякий случай проверка, что есть куда выстрелить (по идее в этом случае игра уже закончена)\r\n    if (targets.length>0)\r\n    {\r\n      // Координаты выстрела\r\n      let fire_coord=primary_targets.length>0?primary_targets[getRandomInt(0, primary_targets.length-1)]:targets[getRandomInt(0, targets.length-1)];\r\n\r\n      let alphabetical_coord=codeCoordinate(fire_coord.x, fire_coord.y);\r\n\r\n      /*\r\n      if (fireMyBoard(alphabetical_coord))\r\n      {\r\n        // если попал, проверяем, победа это или запускаем следующий ход оппонента\r\n        let playerLivesCount=0;\r\n        for (let y = 0; y < 10; y++) {\r\n          for (let x = 0; x < 10; x++) {\r\n            // если туда еще не стреляли\r\n            if (!field[y][x].shot&&field[y][x].containsShip)\r\n              playerLivesCount++;\r\n          }\r\n        }\r\n        //if (playerLivesCount>0)\r\n        //  setTimeout(() => processEnemyMove(), 1200);\r\n        //else\r\n        if (playerLivesCount<=0)\r\n        {\r\n          //setAppState({...appState, gameOver: true, youWin: false});\r\n          assistantRef.current?.sendData({ action: { action_id: 'gameOverLost', parameters: {} } });\r\n        }\r\n        return;\r\n      }\r\n      */\r\n     dispatch({ type: \"enemy_fire\", coord_str: alphabetical_coord});\r\n    }\r\n    // В остальных случаях ход переходит к игроку\r\n    //setAppState({...appState, enemyTurn: false});\r\n  }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nfunction myByCode(s: string)\r\n{\r\n  let result=\"\";\r\n  for (let i=0; i<s.length; i++)\r\n  {\r\n    result=result+s.codePointAt(i)?.toString()+\",\";\r\n  }\r\n  return result;\r\n}\r\n\r\n\r\n  function _renderResult() {\r\n\r\n    //const { game, playerId, winnerId } = this.props;\r\n    const {youWin} = appState;\r\n  \r\n    const message = youWin ? 'Вы победили!' : 'Вы потерпели крушение, сухопутный!';\r\n  \r\n    //setDocumentTitle(`${message} · #${game.id}`);\r\n  \r\n    return (\r\n      <div id=\"game_result\">\r\n        <header>\r\n        {/*<Logo/>*/}\r\n          <h1>Игра окончена</h1>\r\n          <p>{message}</p>\r\n        </header>\r\n        {/*<Link to=\"/\">Back to home</Link>*/}\r\n      </div>\r\n    );\r\n  }\r\n  \r\n  function _renderOpponentBoard() {\r\n    //const { dispatch, game, gameChannel, playerId, currentTurn, readyForBattle } = this.props;\r\n  \r\n    /*\r\n    if (!readyForBattle) return (\r\n        <Instructions\r\n            readyForBattle={readyForBattle}\r\n            playerIsAttacker={playerId === game.attacker}/>\r\n    );\r\n     */\r\n  \r\n    //const opponentBoard = this.state.opponent_board_0;\r\n    // а вот через data к ним можно бы обратиться только внутри OpponentBoard\r\n    const remaining_hit_points = appState.opponent_board.remaining_hit_points;\r\n  \r\n    return (\r\n      <div id=\"opponents_board_container\">\r\n        <header><h2>Поле для стрельбы</h2></header>        \r\n        <OpponentBoard\r\n          //dispatch={dispatch}\r\n          //gameChannel={gameChannel}\r\n          data={appState.opponent_board}\r\n          showHidden={appState.showHidden}\r\n          //playerId={playerId}\r\n          //currentTurn={currentTurn}\r\n          //onClickBoard={() => dispatch({ type: \"add_note\", note: \"123\" })}\r\n          // TODO\r\n          onClickBoard={(x:any, y:any) => dispatch({ type: \"lets_fire\", coord_str: codeCoordinate(x,y)})}\r\n        />\r\n        <p>Попаданий до победы: {remaining_hit_points}/{myByCode(appState.debugLastUserTalkCoord)}</p>\r\n      </div>\r\n    );\r\n  \r\n  }\r\n  \r\n  \r\n  // 559x568, 768x400, 959x400, 1920x1080\r\n  function _renderGameContent() {\r\n    if (appState.gameOver) return _renderResult();\r\n  \r\n    return (\r\n      <section id=\"main_section\">\r\n        {\r\n          <Header\r\n          //game={GameShowView}\r\n          //playerId={playerId}\r\n          enemyTurn={appState.enemyTurn}\r\n          respectfulAppeal={appState.respectfulAppeal}\r\n          >\r\n          </Header>\r\n        }\r\n        <section id=\"boards_container\">\r\n          <div id=\"my_board_container\">\r\n            <header><h2>Свои корабли</h2></header>\r\n            <MyBoard\r\n              //dispatch={dispatch}\r\n              //gameChannel={gameChannel}\r\n              //selectedShip={selectedShip}\r\n              data={appState.my_board}\r\n            />\r\n          </div>\r\n          {\r\n            _renderOpponentBoard()\r\n          }\r\n        </section>\r\n      </section>\r\n    );\r\n  \r\n  }\r\n  \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n  return (\r\n    <AppStyled>\r\n    {/* Используем глобальные react-компоненты один раз */}\r\n    <TypoScale />\r\n    <DocStyles />\r\n    {(() => {\r\n                switch (appState.character) {\r\n                    case 'sber':\r\n                        return <ThemeBackgroundSber />;\r\n                    case 'eva':\r\n                        return <ThemeBackgroundEva />;\r\n                    case 'joy':\r\n                        return <ThemeBackgroundJoy />;\r\n                    default:\r\n                        return;\r\n                }\r\n            })()}    \r\n    {/*<Theme />*/}\r\n    {/*<Button onClick={() => doneNote(\"Test!\")}>Normal Button</Button>*/}\r\n    <main id=\"game_show\" className=\"view-container\">\r\n      {_renderGameContent()}\r\n      {/*\r\n      <form\r\n        onSubmit={(event) => {\r\n          event.preventDefault();\r\n          dispatch({ type: \"add_note\", note });\r\n          setNote(\"\");\r\n        }}\r\n      >\r\n        <input\r\n          className=\"add-note\"\r\n          type=\"text\"\r\n          placeholder=\"Add Note\"\r\n          value={note}\r\n          onChange={({ target: { value } }) => setNote(value)}\r\n          required\r\n          autoFocus\r\n        />\r\n      </form>\r\n      <ul className=\"notes\">\r\n        {appState.notes.map((note, index) => (\r\n          <li className=\"note\" key={note.id}>\r\n            <span>\r\n              <span style={{ fontWeight: \"bold\" }}>{index + 1}. </span>\r\n              <span\r\n                style={{\r\n                  textDecorationLine: note.completed ? \"line-through\" : \"none\",\r\n                }}\r\n              >\r\n                {note.title}\r\n              </span>\r\n            </span>\r\n            <input\r\n              className=\"done-note\"\r\n              type=\"checkbox\"\r\n              checked={note.completed}\r\n              onChange={() => dispatch({ type: \"done_note\", id: note.id })}\r\n            />\r\n          </li>\r\n        ))}\r\n      </ul>\r\n      */}\r\n    </main>\r\n    </AppStyled>\r\n  );\r\n});\r\n","import { ReportHandler } from 'web-vitals';\r\n\r\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\r\n  if (onPerfEntry && onPerfEntry instanceof Function) {\r\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\r\n      getCLS(onPerfEntry);\r\n      getFID(onPerfEntry);\r\n      getFCP(onPerfEntry);\r\n      getLCP(onPerfEntry);\r\n      getTTFB(onPerfEntry);\r\n    });\r\n  }\r\n};\r\n\r\nexport default reportWebVitals;\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport {App} from './App';\r\nimport reportWebVitals from './reportWebVitals';\r\n\r\nReactDOM.render(\r\n  <React.StrictMode>\r\n    <App />\r\n  </React.StrictMode>,\r\n  document.getElementById('root')\r\n);\r\n\r\n// If you want to start measuring performance in your app, pass a function\r\n// to log results (for example: reportWebVitals(console.log))\r\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\r\nreportWebVitals();\r\n"],"sourceRoot":""}