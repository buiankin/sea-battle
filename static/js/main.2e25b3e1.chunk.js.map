{"version":3,"sources":["components/header.js","constants/index.js","constants/messages.js","components/board.js","components/my_board.js","components/opponent_board.js","utils/Common.js","utils/placeShip.js","utils/checkPlaceShip.js","utils/standardShipsSet.js","store.ts","App.tsx","reportWebVitals.ts","index.tsx"],"names":["Header","this","props","enemyTurn","respectfulAppeal","id","_titleText","React","Component","letters","letters_names","Board","data","showHidden","grid","rows","_buildRowHeader","y","cells","className","x","push","_renderCell","value","key","classes","_cellId","_cellClasses","onClick","_handleCellClick","onDoubleClick","e","preventDefault","onMouseOver","_handleCellMouseOver","onMouseOut","_handleCellMouseOut","_cellValue","values","i","_boardClasses","_renderRows","MyBoard","_toggleCellClasses","selectedShip","classnames","pointer","cell","ship","Constants","ref","orientation","size","inbounds","overlapping","coords","OpponentBoard","onClickBoard","playerId","currentTurn","hit","getRandomInt","min","max","Math","ceil","floor","random","codeCoordinate","decodeCoordinate","s","result","s2","replace","toUpperCase","digits_alphabetical","idx","length","lastIndexOf","substring","toString","includes","parseInt","field","direction","startSquare","containsShip","shipId","offsets","j","Ship","incrementId","hitpoints","latestId","placeVarious","enemyField","shot","isShipVisible","variableSet","l","checkPlaceShip","placeShip","getFullInitialState","boardInitialState","initial_myField","Array","myShips","initial_enemyField","enemyShips","val_in_line","enemy_val_in_line","forEach","ship0","my_grid","enemy_grid","remaining_hit_points","my_line","enemy_line","fieldVal","fieldVal_0","my_board","myField","opponent_board","getBoardInitialState","actionsToSend","debugLastUserTalkCoord","character","enemyTurnForce","gameOver","youWin","emptyRow","emptyGrid","initialState","reducer","state","action","type","character_id","slice","coord","coord_str","newMyField","live_parts","Action","action_id","parameters","playerLivesCount","newEnemyField","Error","AppStyled","styled","div","body1","TypoScale","createGlobalStyle","sberBox","DocStyles","text","background","gradient","ThemeBackgroundEva","darkEva","ThemeBackgroundSber","darkSber","ThemeBackgroundJoy","darkJoy","App","memo","useReducer","appState","dispatch","assistantStateRef","useRef","assistantRef","_renderOpponentBoard","useEffect","getState","current","console","log","process","createAssistant","on","navigation","insets","element","sendData","setTimeout","offsets4","primary_area","from","_","fill","live_ships","Set","add","_x","_y","primary_targets","targets","canFire","has","fire_coord","max_len","mega_primary","dir","count","alphabetical_coord","codeCoordinateNames","processEnemyMove","message","_renderResult","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.2e25b3e1.chunk.js","sourcesContent":["import React, {Component} from 'react';\r\nimport PropTypes from 'prop-types'\r\n//import { setDocumentTitle }   from '../../utils';\r\n//import MyBoard from \"./my_board\";\r\n\r\nexport default class Header extends React.Component {\r\n\r\n  componentDidUpdate() {\r\n    //const { game } = this.props;\r\n    // TODO\r\n    //setDocumentTitle(`${this._titleText()} · #${game.id}`);\r\n  }\r\n\r\n  _titleText() {\r\n    //const { game, playerId, currentTurn, my_board, opponents_board } = this.props;\r\n    //const { readyForBattle } = game;\r\n    //let readyForBattle=true;\r\n    const { enemyTurn, respectfulAppeal } = this.props;\r\n\r\n    /*\r\n\r\n    if (!my_board.ready) {\r\n      return 'Place your ships';\r\n    } else if (!opponents_board || !opponents_board.ready) {\r\n      return 'Waiting for opponent';\r\n    } else if (currentTurn && currentTurn === playerId) {\r\n      return 'Your turn!';\r\n    } else if (currentTurn && currentTurn != playerId) {\r\n      return 'Your opponent\\'s turn!';\r\n    } else {\r\n      return 'Let the battle begin';\r\n    }\r\n     */\r\n    if (enemyTurn===true) {\r\n      return respectfulAppeal===false?'Ход твоего оппонента!':'Ход Вашего оппонента!';\r\n    } else {\r\n      return respectfulAppeal===false?'Твой ход!':'Ваш ход!';\r\n    }\r\n    \r\n  }\r\n\r\n  _messageText() {\r\n    const { enemyTurn, respectfulAppeal } = this.props;\r\n    /*\r\n    const { game, playerId, currentTurn } = this.props;\r\n    const { my_board, opponents_board, readyForBattle } = game;\r\n\r\n    if (!my_board.ready) {\r\n      return 'Use the instructions below';\r\n    } else if (!opponents_board || !opponents_board.ready) {\r\n      return 'Battle will start as soon as your opponent is ready';\r\n    } else if (currentTurn && currentTurn === playerId) {\r\n      return 'Click on your shooting grid to open fire!';\r\n    } else if (currentTurn && currentTurn != playerId) {\r\n      return 'Wait for your opponent to shoot...';\r\n    } else {\r\n      return 'Let the battle begin';\r\n    }\r\n     */\r\n    if (enemyTurn===true) {\r\n      return respectfulAppeal===false?'Ход твоего оппонента!':'Ход Вашего оппонента!';\r\n    } else {\r\n      return respectfulAppeal===false?'Твой ход!':'Ваш ход!';\r\n    }\r\n  }\r\n\r\n  render() {\r\n    return (\r\n      <header id=\"game_header\">\r\n        <h1>{this._titleText()}</h1>\r\n        {/*<p>{this._messageText()}</p>*/}\r\n      </header>\r\n    );\r\n  }\r\n}\r\n","export default {\r\n\r\n  // Session\r\n  SESSION_SET_PLAYER: 'SESSION_SET_PLAYER',\r\n\r\n  //  Home\r\n  HOME_NEW_GAME: 'HOME_NEW_GAME',\r\n  HOME_SET_CURRENT_GAMES: 'HOME_SET_CURRENT_GAMES',\r\n\r\n  // Game\r\n  GAME_SET_CHANNEL: 'GAME_SET_CHANNEL',\r\n  GAME_PLAYER_JOINED: 'GAME_PLAYER_JOINED',\r\n  GAME_PLAYER_LEFT: 'GAME_PLAYER_LEFT',\r\n  GAME_SET_GAME: 'GAME_SET_GAME',\r\n  GAME_ADD_MESSAGE: 'GAME_ADD_MESSAGE',\r\n  GAME_SETUP_SELECT_SHIP: 'GAME_SETUP_SELECT_SHIP',\r\n  GAME_OPPONENTS_BOARD_UPDATE: 'GAME_OPPONENTS_BOARD_UPDATE',\r\n  GAME_RESET: 'GAME_RESET',\r\n  GAME_OVER: 'GAME_OVER',\r\n  GAME_ERROR: 'GAME_ERROR',\r\n\r\n  //Ships\r\n  SHIP_ORIENTATION_HORIZONTAL: 'horizontal',\r\n  SHIP_ORIENTATION_VERTICAL: 'vertical',\r\n\r\n  // Boards\r\n  GRID_VALUE_WATER: '·',\r\n  GRID_VALUE_SHIP: '/',\r\n  GRID_VALUE_WATER_HIT: 'O',\r\n  GRID_VALUE_SHIP_HIT: '*',\r\n};\r\n","\r\nexport const letters = ['А', 'Б', 'В', 'Г', 'Д', 'Е', 'Ж', 'З', 'И', 'К'];\r\n\r\nexport const letters_names = ['Альфа', 'Браво', 'Виктор', 'Гольф', 'Дельта', 'Эхо', 'Жора', 'Зулу', 'Игорь', 'Кирилл'];\r\n\r\n//export const hello_messages = ['Привет!'];\r\n//export const hit_messages = ['Неплохо для слепого!'];\r\n//export const miss_messages = ['Мазила!', 'Мимо!', 'Промах!'];\r\n//export const kill_messages = ['Убил!'];\r\n//export const dont_understand = ['Моя твоя не понимай!'];\r\n\r\n","import React, {PropTypes} from 'react';\r\nimport classnames         from 'classnames';\r\nimport Constants from '../constants';\r\nimport {letters} from '../constants/messages';\r\n//import { setGame }        from '../../actions/game';\r\n\r\nexport default class Board extends React.Component {\r\n\r\n  constructor(props)\r\n  {\r\n    super(props);\r\n  }\r\n\r\n  _renderRows(data, showHidden) {\r\n\r\n    // showHidden важно только для opponent_board\r\n    const { grid } = data;\r\n\r\n    let rows = [this._buildRowHeader()];\r\n\r\n    for (let y = 0; y < 10; y++) {\r\n      let cells = [<div key={`header-${y}`} className=\"header cell\">{y + 1}</div>];\r\n\r\n      for (let x = 0; x < 10; x++) {\r\n        //cells.push(this._renderCell(y, x, grid[`${y}${x}`]));\r\n        // 15.02.2021 у нас это не строка 00, 01, 02 и т.д., а двухмерный массив\r\n        cells.push(this._renderCell(y, x, grid[y][x], showHidden));\r\n      }\r\n\r\n      rows.push(<div className=\"row\" key={y}>{cells}</div>);\r\n    }\r\n/*\r\n      let rows = [this._buildRowHeader()];\r\n\r\n      for (let y = 0; y < 10; y++) {\r\n          let cells = [<div key={`header-${y}`} className=\"header cell\">{y + 1}</div>];\r\n\r\n          for (let x = 0; x < 10; x++) {\r\n              cells.push(this._renderCell(y, x, '*'));\r\n          }\r\n\r\n          rows.push(<div className=\"row\" key={y}>{cells}</div>);\r\n      }\r\n*/\r\n\r\n\r\n    return rows;\r\n  }\r\n\r\n  _renderCell(y, x, value, showHidden) {\r\n    const key = `${y}${x}`;\r\n    const id = this._cellId(key);\r\n    const classes = this._cellClasses(value, showHidden);\r\n\r\n    return (\r\n      <div\r\n        id={this._cellId(key)}\r\n        className={classes}\r\n        key={key}\r\n        onClick={this._handleCellClick(y, x, value)}\r\n        onDoubleClick={(e) => e.preventDefault()}\r\n        onMouseOver={(y,x)=>this._handleCellMouseOver(y, x)}\r\n        onMouseOut={(y,x)=>this._handleCellMouseOut(y, x)}>{this._cellValue(value)}</div>\r\n    );\r\n  }\r\n\r\n  _buildRowHeader() {\r\n    let values = [<div key=\"empty\" className=\"header cell\"></div>];\r\n\r\n    for (var i = 0; i < 10; ++i) {\r\n      //  values.push(<div key={i} className=\"header cell\">{String.fromCharCode(i + 65)}</div>);\r\n      values.push(<div key={i} className=\"header cell\">{letters[i]}</div>);\r\n    }\r\n\r\n\r\n\r\n    return (\r\n      <div key=\"col-headers\" className=\"row\">\r\n        {values}\r\n      </div>\r\n    );\r\n  }\r\n\r\n  render() {\r\n      // 14.02.2012 TODO\r\n    const { data, showHidden } = this.props;\r\n    //if (!data) return false;\r\n\r\n    const classes = this._boardClasses();\r\n\r\n    return (\r\n      <div className={classes}>\r\n        {this._renderRows(data, showHidden)}\r\n      </div>\r\n    );\r\n  }\r\n}\r\n","import React, {PropTypes} from 'react';\r\nimport classnames         from 'classnames';\r\nimport Board              from './board';\r\nimport Constants          from '../constants';\r\n//import { setGame }        from '../../actions/game';\r\n//import { setError }       from '../../actions/game';\r\n\r\nexport default class MyBoard extends Board {\r\n\r\n    _handleCellClick(y, x, value) {\r\n    //const { selectedShip, gameChannel, dispatch } = this.props;\r\n    //const key = `${y}${x}`;\r\n\r\n    // 14.02.2021 Добавил\r\n    //const ready=true;\r\n    //\r\n\r\n    // Это было в actions\r\n    //  function setGame(game) {\r\n    //    return {\r\n    //      type: Constants.GAME_SET_GAME,\r\n    //      game: game,\r\n    //    };\r\n    //  }\r\n\r\n\r\n    return (e) => {\r\n      //if (selectedShip.id === null) return false;\r\n      if (value != Constants.GRID_VALUE_WATER) return false;\r\n\r\n      //const ship = {\r\n      //  x: x,\r\n      //  y: y,\r\n      //  size: selectedShip.size,\r\n      //  orientation: selectedShip.orientation,\r\n      //};\r\n\r\n      // TODO 08.02.2021\r\n      //gameChannel.push('game:place_ship', { ship: ship })\r\n      //.receive('ok', (payload) => dispatch(setGame(payload.game)));\r\n      //.receive('error', (payload) => dispatch(setError(payload.reason)));\r\n\r\n      return false;\r\n\r\n    };\r\n  }\r\n\r\n  _handleCellMouseOver(y, x) {\r\n    return this._toggleCellClasses(y, x);\r\n  }\r\n\r\n  _handleCellMouseOut(y, x) {\r\n    return this._toggleCellClasses(y, x);\r\n  }\r\n\r\n  _toggleCellClasses(y, x) {\r\n      // TODO это расстановка\r\n      /*\r\n    const { selectedShip } = this.props;\r\n\r\n    if (selectedShip.size === 0) return false;\r\n\r\n    const { size, orientation } = selectedShip;\r\n\r\n    const className = this._validCoords(y, x, orientation, size) ? 'ship-shape' : 'ship-shape-invalid';\r\n\r\n    return (e) => {\r\n      for (var i = 0; i < size; i++) {\r\n        const coords = orientation === 'horizontal' ? `${y}${x + i}` : `${y + i}${x}`;\r\n        let cell = document.getElementById(coords);\r\n        if (!cell) break;\r\n        cell.classList.toggle(className);\r\n      }\r\n    };\r\n       */\r\n  }\r\n\r\n  _cellValue(value) {\r\n    return false;\r\n  }\r\n\r\n  _boardClasses() {\r\n    const { selectedShip } = this.props;\r\n\r\n    return classnames({\r\n      grid: true,\r\n      pointer: selectedShip && selectedShip.id != null,\r\n    });\r\n  }\r\n\r\n  _cellClasses(value, showHidden) {\r\n    return classnames({\r\n      cell: true,\r\n      ship: value === Constants.GRID_VALUE_SHIP,\r\n      'ship-hit': value === Constants.GRID_VALUE_SHIP_HIT,\r\n      'water-hit': value === Constants.GRID_VALUE_WATER_HIT,\r\n    });\r\n  }\r\n\r\n  _cellId(ref) {\r\n    return ref;\r\n  }\r\n\r\n  _validCoords(y, x, orientation, size) {\r\n    const { data } = this.props;\r\n    let inbounds;\r\n\r\n    if (orientation === 'horizontal') {\r\n      inbounds = (x + size) <= 10;\r\n    } else {\r\n      inbounds = (y + size) <= 10;\r\n    }\r\n\r\n    let overlapping = false;\r\n\r\n    for (var i = 0; i < size; i++) {\r\n      const coords = orientation === 'horizontal' ? `${y}${x + i}` : `${y + i}${x}`;\r\n      if (data.grid[coords] != Constants.GRID_VALUE_WATER) {\r\n        overlapping = true;\r\n        break;\r\n      }\r\n    }\r\n\r\n    return inbounds && !overlapping;\r\n  }\r\n}\r\n","import React, {PropTypes} from 'react';\r\nimport classnames         from 'classnames';\r\nimport Board              from './board';\r\nimport Constants          from '../constants';\r\n//import { setGame }        from '../../actions/game';\r\n\r\nexport default class OpponentBoard extends Board {\r\n\r\n  constructor(props) {\r\n    super(props);\r\n\r\n  }\r\n\r\n  _handleCellClick(y, x, value) {\r\n    //const { gameChannel, currentTurn, playerId, dispatch } = this.props;\r\n\r\n    //if (currentTurn !== playerId) return false;\r\n\r\n    //const key = `${y}${x}`;\r\n\r\n    // Это было в actions\r\n    //function setGame(game) {\r\n    //  return {\r\n    //    type: Constants.GAME_SET_GAME,\r\n    //    game: game,\r\n    //  };\r\n    //}\r\n\r\n    return (e) => { \r\n      this.props.onClickBoard(x, y);\r\n    }\r\n\r\n\r\n    //return (e) => {\r\n    //  if (value != Constants.GRID_VALUE_WATER) return false;\r\n\r\n      //gameChannel.push('game:shoot', { y: y, x: x })\r\n      //.receive('ok', (payload) => {\r\n      //  dispatch(setGame(payload.game));\r\n      //})\r\n      //.receive('error', (payload) => console.log(payload));\r\n\r\n\r\n    //};\r\n  }\r\n\r\n  _handleCellMouseOver(y, x) {\r\n    return false;\r\n  }\r\n\r\n  _cellValue(value) {\r\n    return '';\r\n  }\r\n\r\n  _boardClasses() {\r\n    const { playerId, currentTurn } = this.props;\r\n\r\n    return classnames({\r\n      grid: true,\r\n      pointer: playerId === currentTurn,\r\n    });\r\n  }\r\n\r\n  _cellClasses(value, showHidden) {\r\n    return classnames({\r\n      cell: true,\r\n      // TODO только во время отладки\r\n      ship: showHidden && value === Constants.GRID_VALUE_SHIP,\r\n      //\r\n      hit: value === Constants.GRID_VALUE_SHIP_HIT,\r\n      'water-hit': value === Constants.GRID_VALUE_WATER_HIT,\r\n    });\r\n  }\r\n\r\n  _cellId(ref) {\r\n    return false;\r\n  }\r\n\r\n  _handleCellMouseOut(e) {\r\n    return false;\r\n  }\r\n}\r\n","\r\nimport { letters, letters_names } from '../constants/messages';\r\n\r\n\r\nexport function getRandomArbitrary(min, max) {\r\n    return Math.random() * (max - min) + min;\r\n}\r\n\r\nexport function getRandomInt(min, max) {\r\n    min = Math.ceil(min);\r\n    max = Math.floor(max);\r\n    return Math.floor(Math.random() * (max - min + 1)) + min;\r\n}\r\n\r\nexport function codeCoordinate(x, y)\r\n{\r\n  return letters[x]+(y+1);\r\n}\r\n\r\nexport function codeCoordinateNames(x, y)\r\n{\r\n  return letters_names[x]+\" \"+(y+1);\r\n}\r\n\r\n\r\n\r\nexport function decodeCoordinate(s)\r\n{\r\n  let result=null;\r\n\r\n  //s=String.fromCodePoint(1072,1072,32,1086,1076,1080,1085);\r\n  //result={x:3, y:2};\r\n  //return result;\r\n\r\n  //s=\"Валера восемь\";\r\n  //s=s.replaceAll(\"1\", \" ОДИН \");\r\n\r\n  let y=-1;\r\n  let s2=s.replace(\"-\", \" \").toUpperCase();\r\n  const digits_alphabetical=[{idx: 1, s:'ОДИН'}, {idx: 2, s:'ДВА'}, {idx: 4, s:'ЧЕТЫРЕ'}, {idx: 5, s:'ПЯТЬ'},\r\n   {idx: 6, s:'ШЕСТЬ'}, {idx: 8, s:'ВОСЕМЬ'}, {idx: 7, s:'СЕМЬ'}, {idx: 9, s:'ДЕВЯТЬ'}, {idx: 10, s:'ДЕСЯТЬ'}, \r\n   // Три идет последним, на случай если сказали Дмитрий\r\n   {idx: 3, s:'ТРИ'}];\r\n  for (let i=0; i<digits_alphabetical.length; i++)\r\n  {\r\n    //s2=s2.replace(digits_alphabetical[i], (i+1).toString());\r\n    let idx=s2.lastIndexOf(digits_alphabetical[i].s);\r\n    if (idx>=0)\r\n    {\r\n      s2 = s2.substring(0, idx) + (digits_alphabetical[i].idx).toString() + s2.substring(idx + digits_alphabetical[i].s.length);\r\n      break;\r\n    }\r\n  }\r\n\r\n  s2=s2.replace(/ /g, \"\");\r\n\r\n  // 08.04.2021\r\n  // все, что не на первом и не на последнем месте и не цифра, заменяем на пробел\r\n  // пока такая простейшая проверка на координаты типа Игорь-3\r\n  for (let i=1; i<s2.length-1; i++)\r\n  {\r\n    if (!('0123456789'.includes(s2[i])))\r\n    {\r\n      s2 = s2.substring(0, i) + ' ' + s2.substring(i + 1);\r\n    }\r\n  }\r\n  //\r\n\r\n  s2=s2.replace(/ /g, \"\");\r\n\r\n  if (s2.length===3&&s2.substring(1)===\"10\")\r\n  {\r\n    y=9;\r\n  } else if (s2.length===2) {\r\n    if ('0123456789'.includes(s2.substring(2)))\r\n      y=parseInt(s2.substring(1))-1;\r\n  }\r\n  if (y>=0)\r\n  {\r\n    switch (s2.substring(0,1))\r\n    {\r\n      case 'А':\r\n        result={x:0, y:y};\r\n        break;\r\n      case 'Б':\r\n        result={x:1, y:y};\r\n        break;\r\n      case 'В':\r\n        result={x:2, y:y};\r\n        break;\r\n      case 'Г':\r\n        result={x:3, y:y};\r\n        break;\r\n      case 'Д':\r\n        result={x:4, y:y};\r\n        break;\r\n      case 'Е':\r\n        result={x:5, y:y};\r\n        break;\r\n      case 'Э': // это так бот говорит букву Е - Эхо\r\n        result={x:5, y:y};\r\n        break;\r\n      case 'Ж':\r\n        result={x:6, y:y};\r\n        break;\r\n      case 'З':\r\n        result={x:7, y:y};\r\n        break;\r\n      case 'И':\r\n        result={x:8, y:y};\r\n        break;\r\n      case 'К':\r\n        result={x:9, y:y};\r\n        break;\r\n    }\r\n  }\r\n  return result;\r\n\r\n}","// небольшая функция-сниппет, которая добавляет корабль на поле\r\n// сдвиг на единицу появился из-за отсчета индекса массива с нуля\r\n\r\nexport default (field, ship) => {\r\n    switch(ship.direction) {\r\n        case 'right': \r\n        for (let i = ship.startSquare.x - 1; i < ship.startSquare.x - 1 + ship.size; i++) {\r\n            field[ship.startSquare.y - 1][i].containsShip = true;\r\n            field[ship.startSquare.y - 1][i].shipId = ship.id;\r\n        }\r\n        break;\r\n        case 'down': \r\n        for (let i = ship.startSquare.y - 1; i < ship.startSquare.y - 1 + ship.size; i++) {\r\n            field[i][ship.startSquare.x - 1].containsShip = true;\r\n            field[i][ship.startSquare.x - 1].shipId = ship.id;\r\n        }\r\n        break;\r\n        default:\r\n    }\r\n}\r\n","\r\nexport default (field, ship) => {\r\n    const offsets=[{x:-1,y:-1}, {x:0,y:-1}, {x:1,y:-1},\r\n        {x:-1,y:0}, {x:0,y:0}, {x:1,y:0},\r\n        {x:-1,y:1}, {x:0,y:1}, {x:1,y:1},\r\n    ];\r\n    switch(ship.direction) {\r\n        case 'right':\r\n            for (let i = ship.startSquare.x - 1; i < ship.startSquare.x - 1 + ship.size; i++) {\r\n                //field[ship.startSquare.y - 1][i].containsShip = true;\r\n                //field[ship.startSquare.y - 1][i].shipId = ship.id;\r\n                for (let j=0; j<offsets.length; j++)\r\n                {\r\n                    let y=offsets[j].y+ship.startSquare.y - 1;\r\n                    let x=offsets[j].x+i;\r\n                    if (x<0||y<0||x>=10|y>=10)\r\n                    {\r\n                        // корабль находится в углу поля, там других кораблей нет\r\n                    } else {\r\n                        if (field[y][x].containsShip)\r\n                            return false;\r\n                    }\r\n                }\r\n\r\n            }\r\n            break;\r\n        case 'down':\r\n            for (let i = ship.startSquare.y - 1; i < ship.startSquare.y - 1 + ship.size; i++) {\r\n                //field[i][ship.startSquare.x - 1].containsShip = true;\r\n                //field[i][ship.startSquare.x - 1].shipId = ship.id;\r\n                for (let j=0; j<offsets.length; j++)\r\n                {\r\n                    let y=offsets[j].y+i;\r\n                    let x=offsets[j].x+ship.startSquare.x - 1;\r\n                    if (x<0||y<0||x>=10|y>=10)\r\n                    {\r\n                        // корабль находится в углу поля, там других кораблей нет\r\n                    } else {\r\n                        if (field[y][x].containsShip)\r\n                            return false;\r\n                    }\r\n                }\r\n\r\n            }\r\n            break;\r\n        default:\r\n    }\r\n    return true;\r\n}","// компонент, который создает и экспортирует стандартный набор кораблей\r\n// направление кораблю задается для того, чтобы можно было определить, в какую сторону его рисовать из стартовой точки\r\n// Размещать корабли можно либо вертикально, либо горизонтально, были выбраны направления вправо(right) и вниз(down), \r\n// поскольку они совпадают с положительными направлениеми координатных осей\r\n\r\nimport {getRandomInt} from './Common'\r\nimport placeShip from \"./placeShip\";\r\nimport checkPlaceShip from \"./checkPlaceShip\";\r\n\r\nclass Ship {\r\n    constructor(size, startSquare, direction) {\r\n        this.size = size;\r\n        this.startSquare = startSquare;\r\n        this.direction = direction;\r\n        this.id = Ship.incrementId();\r\n        this.hitpoints = this.size;\r\n    }\r\n\r\n    static incrementId() {\r\n        if (!this.latestId) {\r\n            this.latestId = 1;\r\n        } else {\r\n            this.latestId++;\r\n        }\r\n        return this.latestId\r\n    }\r\n}\r\n\r\n\r\nexport function placeVarious()\r\n{\r\n    let enemyField = [];\r\n\r\n    // первоначальное (пустое) состояние поля\r\n    for (let i = 0; i < 10; i++) {\r\n        enemyField.push([]);\r\n    }\r\n\r\n    for (let i = 0; i < 10; i++) {\r\n        for (let j = 0; j < 10; j++) {\r\n            enemyField[i].push({\r\n                x: j,\r\n                y: i,\r\n                containsShip: false,\r\n                shot: false,\r\n                isShipVisible: false,\r\n                shipId: null,\r\n            });\r\n        }\r\n    }\r\n\r\n\r\n    let variableSet = [];\r\n    // i-порядок расстановки (оно же количество короблей такой длины)\r\n    // и соответственно длина на каждом уровне  5-i\r\n    for (let i=1; i<=4; i++)\r\n    //for (let i=1; i<=1; i++)\r\n    {\r\n        for (let j=1; j<=i; j++)\r\n        {\r\n            // длина корабля\r\n            let l=5-i;\r\n            let ship, x, y;\r\n            for(;;) {\r\n                x = getRandomInt(1, 10 - l + 1);\r\n                y = getRandomInt(1, 10);\r\n\r\n                let direction=Math.random();\r\n                if (direction>= 0.5) {\r\n                    ship = new Ship(l, {y: y, x: x}, 'right');\r\n                } else {\r\n                    ship = new Ship(l, {y: x, x: y}, 'down');\r\n                }\r\n                if (checkPlaceShip(enemyField, ship))\r\n                   break;\r\n            }\r\n            placeShip(enemyField, ship);\r\n            variableSet.push(ship);\r\n        }\r\n\r\n    }\r\n    return variableSet;\r\n}\r\n\r\nexport default placeVarious;","import Constants from './constants';\r\nimport { codeCoordinate, decodeCoordinate} from './utils/Common';\r\n\r\nimport MyBoard from './components/my_board'\r\nimport OpponentBoard from './components/opponent_board';\r\n\r\nimport placeShip from './utils/placeShip';\r\nimport placeVarious from './utils/standardShipsSet';\r\n\r\nfunction getBoardInitialState()\r\n{\r\n  let initial_myField = Array(0);\r\n  let myShips = placeVarious();\r\n\r\n  let initial_enemyField = Array(0);\r\n  let enemyShips = placeVarious();\r\n\r\n\r\n  // первоначальное (пустое) состояние поля\r\n  //for (let i = 0; i < 10; i++) {\r\n  //  initial_myField.push([]);\r\n  //  initial_enemyField.push([]);\r\n  //}\r\n\r\n  for (let i = 0; i < 10; i++) {\r\n    let val_in_line = [];\r\n    let enemy_val_in_line = [];\r\n\r\n    for (let j = 0; j < 10; j++) {\r\n      val_in_line.push({\r\n        x: j,\r\n        y: i,\r\n        containsShip: false,\r\n        shot: false,\r\n        isShipVisible: false,\r\n        shipId: null,\r\n      });\r\n\r\n      enemy_val_in_line.push({\r\n        x: j,\r\n        y: i,\r\n        containsShip: false,\r\n        shot: false,\r\n        isShipVisible: false,\r\n        shipId: null,\r\n      });\r\n    }\r\n\r\n    initial_myField.push(val_in_line);\r\n    initial_enemyField.push(enemy_val_in_line);\r\n  }\r\n\r\n    // расставляем стандартный набор кораблей\r\n    myShips.forEach((ship: any) => {\r\n      placeShip(initial_myField, ship)\r\n    });\r\n    enemyShips.forEach((ship0: any) => {\r\n      placeShip(initial_enemyField, ship0)\r\n    });\r\n\r\n\r\n  let my_grid = [];\r\n  let enemy_grid = [];\r\n\r\n  // Заполняем из наших массивов\r\n  let remaining_hit_points = 0;\r\n  for (let y = 0; y < 10; y++) {\r\n    let my_line = [];\r\n    let enemy_line = [];\r\n    for (let x = 0; x < 10; x++) {\r\n      // Наши корабли\r\n      let fieldVal = initial_myField[y][x];\r\n      let fieldVal_0 = fieldVal.shot ? Constants.GRID_VALUE_WATER_HIT : Constants.GRID_VALUE_WATER;\r\n      if (fieldVal.containsShip)\r\n        fieldVal_0 = fieldVal.shot ? Constants.GRID_VALUE_SHIP_HIT : Constants.GRID_VALUE_SHIP;\r\n      my_line.push(fieldVal_0);\r\n      // Корабли оппонента\r\n      fieldVal = initial_enemyField[y][x];\r\n      fieldVal_0 = fieldVal.shot ? Constants.GRID_VALUE_WATER_HIT : Constants.GRID_VALUE_WATER;\r\n      if (fieldVal.containsShip) {\r\n        fieldVal_0 = fieldVal.shot ? Constants.GRID_VALUE_SHIP_HIT : Constants.GRID_VALUE_SHIP;\r\n        remaining_hit_points++;\r\n      }\r\n      enemy_line.push(fieldVal_0);\r\n    }\r\n\r\n    my_grid.push(my_line);\r\n    enemy_grid.push(enemy_line);\r\n\r\n  }\r\n\r\n  let initial_my_board = { grid: my_grid };\r\n  let initial_opponent_board = { grid: enemy_grid, remaining_hit_points};\r\n\r\n  return {\r\n    //notes: [],\r\n\r\n    my_board: initial_my_board,\r\n    myField: initial_myField,\r\n    opponent_board: initial_opponent_board,\r\n    enemyField: initial_enemyField\r\n    \r\n  };\r\n\r\n}\r\n\r\nfunction getFullInitialState()\r\n{\r\n  let boardInitialState=getBoardInitialState();\r\n  let state={\r\n    actionsToSend: [],\r\n    debugLastUserTalkCoord: \"\",\r\n\r\n\r\n    my_board: boardInitialState.my_board,\r\n    myField: boardInitialState.myField,\r\n    opponent_board: boardInitialState.opponent_board,\r\n    enemyField: boardInitialState.enemyField,\r\n    character: 'sber',\r\n    respectfulAppeal: true, \r\n    enemyTurnForce: 0,\r\n    enemyTurn: false, gameOver: false, youWin: false,\r\n    // TODO true, если надо сразу видеть\r\n    showHidden: false\r\n  };\r\n  return state;\r\n}\r\n\r\n\r\nconst emptyRow=[Constants.GRID_VALUE_WATER, Constants.GRID_VALUE_WATER, Constants.GRID_VALUE_WATER, Constants.GRID_VALUE_WATER, Constants.GRID_VALUE_WATER,\r\n  Constants.GRID_VALUE_WATER, Constants.GRID_VALUE_WATER, Constants.GRID_VALUE_WATER, Constants.GRID_VALUE_WATER, Constants.GRID_VALUE_WATER];\r\nconst emptyGrid=[emptyRow,emptyRow,emptyRow,emptyRow,emptyRow,emptyRow,emptyRow,emptyRow,emptyRow,emptyRow];\r\n\r\n// важно - тот же самый тип должен быть у getFullInitialState()\r\nexport const initialState = { actionsToSend: [], debugLastUserTalkCoord: \"\", my_board: {grid: emptyGrid}, myField: [], opponent_board: {grid: emptyGrid, remaining_hit_points:0}, enemyField: [],\r\n  character: 'sber',\r\n  respectfulAppeal: true, \r\n  enemyTurnForce: 0,\r\n  enemyTurn: false, gameOver: false, youWin: false,\r\n  showHidden: false\r\n};\r\n\r\n\r\n/*\r\ntype Note = {\r\n  id: string;\r\n  title: string;\r\n  completed: boolean;\r\n};\r\n*/\r\n\r\ntype ActionToSend = {\r\n  id: string;\r\n  Action: { action: any };\r\n}\r\n\r\ntype State = {\r\n  //notes: Array<Note>;\r\n  actionsToSend: Array<ActionToSend>,\r\n  debugLastUserTalkCoord: string,\r\n\r\n  my_board: { grid: string[][]},\r\n  myField: any[],\r\n  opponent_board: { grid: string[][], remaining_hit_points: number},\r\n  enemyField: any[],\r\n\r\n  character: string,\r\n  respectfulAppeal: boolean, \r\n  enemyTurnForce: number, enemyTurn: boolean, gameOver: boolean, youWin: boolean,\r\n  showHidden: boolean\r\n};\r\n\r\ntype Action =\r\n  | {\r\n    type: \"init\";\r\n  }\r\n  | {\r\n    type: \"show_ships\";\r\n  }\r\n  | {\r\n    type: \"character\";\r\n    character_id: string;\r\n    }\r\n  | {\r\n    type: \"game_over_lost\";\r\n    }\r\n  | {\r\n    type: \"game_replay\";\r\n    }\r\n  | {\r\n    type: \"clear_action\";\r\n    id: string;\r\n    }\r\n  | {\r\n    type: \"enemy_fire\";\r\n    coord_str: string;\r\n  }\r\n  | {\r\n    type: \"lets_fire\";\r\n    coord_str: string;\r\n  };\r\n\r\n  /*\r\n  | {\r\n      type: \"add_note\";\r\n      note: string;\r\n    }\r\n  | {\r\n      type: \"done_note\";\r\n      id: string;\r\n    }\r\n  | {\r\n      type: \"delete_note\";\r\n      id: string;\r\n    };\r\n    */\r\n\r\nexport const reducer = (state: State, action: Action) => {\r\n\r\n  switch (action.type) {\r\n      /*\r\n    case \"init\":\r\n      let initial_myField = Array(0);\r\n      let myShips = placeVarious();\r\n    \r\n      let initial_enemyField = Array(0);\r\n      let enemyShips = placeVarious();\r\n    \r\n    \r\n      // первоначальное (пустое) состояние поля\r\n      //for (let i = 0; i < 10; i++) {\r\n      //  initial_myField.push([]);\r\n      //  initial_enemyField.push([]);\r\n      //}\r\n    \r\n      for (let i = 0; i < 10; i++) {\r\n        let val_in_line = [];\r\n        let enemy_val_in_line = [];\r\n    \r\n        for (let j = 0; j < 10; j++) {\r\n          val_in_line.push({\r\n            x: j,\r\n            y: i,\r\n            containsShip: false,\r\n            shot: false,\r\n            isShipVisible: false,\r\n            shipId: null,\r\n          });\r\n    \r\n          enemy_val_in_line.push({\r\n            x: j,\r\n            y: i,\r\n            containsShip: false,\r\n            shot: false,\r\n            isShipVisible: false,\r\n            shipId: null,\r\n          });\r\n        }\r\n    \r\n        initial_myField.push(val_in_line);\r\n        initial_enemyField.push(enemy_val_in_line);\r\n      }\r\n    \r\n        // расставляем стандартный набор кораблей\r\n        myShips.forEach((ship: any) => {\r\n          placeShip(initial_myField, ship)\r\n        });\r\n        enemyShips.forEach((ship0: any) => {\r\n          placeShip(initial_enemyField, ship0)\r\n        });\r\n    \r\n    \r\n      let my_grid = [];\r\n      let enemy_grid = [];\r\n    \r\n      // Заполняем из наших массивов\r\n      let remaining_hit_points = 0;\r\n      for (let y = 0; y < 10; y++) {\r\n        let my_line = [];\r\n        let enemy_line = [];\r\n        for (let x = 0; x < 10; x++) {\r\n          // Наши корабли\r\n          let fieldVal = initial_myField[y][x];\r\n          let fieldVal_0 = fieldVal.shot ? Constants.GRID_VALUE_WATER_HIT : Constants.GRID_VALUE_WATER;\r\n          if (fieldVal.containsShip)\r\n            fieldVal_0 = fieldVal.shot ? Constants.GRID_VALUE_SHIP_HIT : Constants.GRID_VALUE_SHIP;\r\n          my_line.push(fieldVal_0);\r\n          // Корабли оппонента\r\n          fieldVal = initial_enemyField[y][x];\r\n          fieldVal_0 = fieldVal.shot ? Constants.GRID_VALUE_WATER_HIT : Constants.GRID_VALUE_WATER;\r\n          if (fieldVal.containsShip) {\r\n            fieldVal_0 = fieldVal.shot ? Constants.GRID_VALUE_SHIP_HIT : Constants.GRID_VALUE_SHIP;\r\n            remaining_hit_points++;\r\n          }\r\n          enemy_line.push(fieldVal_0);\r\n        }\r\n    \r\n        my_grid.push(my_line);\r\n        enemy_grid.push(enemy_line);\r\n    \r\n      }\r\n    \r\n      let initial_my_board = { grid: my_grid };\r\n      let initial_opponent_board = { grid: enemy_grid, remaining_hit_points};\r\n    \r\n      return {\r\n        notes: [],\r\n        my_board: initial_my_board,\r\n        myField: initial_myField,\r\n        opponent_board: initial_opponent_board,\r\n        enemyField: initial_enemyField\r\n      };\r\n      */\r\n\r\n    case \"init\":\r\n      return getFullInitialState();\r\n\r\n\r\n    case \"character\":\r\n      return {\r\n        ...state,\r\n        character: action.character_id, respectfulAppeal: action.character_id!=='joy'\r\n      }\r\n  \r\n    case \"show_ships\":\r\n      return {\r\n        ...state,\r\n        showHidden: true\r\n      }\r\n\r\n    case \"game_over_lost\":\r\n      return {\r\n        ...state,\r\n        gameOver: true, youWin: false\r\n      }\r\n\r\n    case \"game_replay\":\r\n      return {\r\n        ...getFullInitialState(),\r\n        character: state.character,\r\n        respectfulAppeal: state.respectfulAppeal\r\n      }\r\n\r\n    case \"clear_action\":\r\n      return {\r\n        ...state,\r\n        actionsToSend: []\r\n      }\r\n\r\n    case \"enemy_fire\":\r\n    {\r\n      let actionsToSend=state.actionsToSend.slice();\r\n\r\n      let fire_registered=false;\r\n      let coord=decodeCoordinate(action.coord_str);\r\n      if (coord)\r\n      {\r\n        let x=coord.x, y=coord.y;\r\n\r\n        let field=state.myField[y][x];\r\n        if (field.containsShip)\r\n        {\r\n          // Попали в корабль\r\n          if (!field.shot)\r\n          {\r\n            // До этого в это поле не попадали\r\n            fire_registered=true;\r\n            let newMyField=state.myField.slice();\r\n            newMyField[y]=newMyField[y].slice();\r\n            newMyField[y][x]={...newMyField[y][x], shot:true};\r\n            let shipId=field.shipId;\r\n            // Проверим, есть ли еще не подбитые его части\r\n            let live_parts=0;\r\n            for (let y = 0; y < 10; y++) {\r\n              for (let x = 0; x < 10; x++) {\r\n                if (newMyField[y][x].containsShip && newMyField[y][x].shipId===shipId)\r\n                {\r\n                  if (!newMyField[y][x].shot)\r\n                    live_parts++;\r\n                }\r\n              }\r\n            }\r\n            // TODO если корабль полностью подбит, рисовать его как-то по-другому\r\n        \r\n            let grid=state.my_board.grid.slice();\r\n            grid[y]=state.my_board.grid[y].slice();\r\n            grid[y][x] = Constants.GRID_VALUE_SHIP_HIT;\r\n            if (live_parts>0)\r\n              actionsToSend.push({id:'0', Action: { action: { action_id: 'enemy_fire_hit', parameters: { coord: action.coord_str} } }});\r\n            else\r\n              actionsToSend.push({id:'0', Action: { action: { action_id: 'enemy_fire_down', parameters: { coord: action.coord_str} } }});\r\n\r\n            // посчитаем, сколько у игрока осталось кораблей\r\n            let playerLivesCount=0;\r\n            for (let y = 0; y < 10; y++) {\r\n              for (let x = 0; x < 10; x++) {\r\n                // если туда еще не стреляли\r\n                if (!newMyField[y][x].shot&&newMyField[y][x].containsShip)\r\n                  playerLivesCount++;\r\n              }\r\n            }\r\n           \r\n            if (playerLivesCount>0)\r\n            {\r\n              // TODO еще один выстрел\r\n            //  setTimeout(() => processEnemyMove(), 3100);\r\n\r\n              // просто очередное попадание, ход не переходит\r\n              return {...state,\r\n                my_board: {grid: grid},\r\n                myField: newMyField,\r\n                actionsToSend: actionsToSend,\r\n                // а это сделано для того, чтобы вызвалась проверка enemyTurn\r\n                enemyTurnForce: state.enemyTurnForce+1\r\n                }\r\n  \r\n            } else\r\n            {\r\n              // Игра окончена\r\n              //setAppState({...appState, gameOver: true, youWin: false});\r\n              actionsToSend.push({id:'0', Action: { action: { action_id: 'gameOverLost', parameters: {} } }});\r\n              // игрок выиграл\r\n              return {...state,\r\n                my_board: {grid: grid},\r\n                myField: newMyField,\r\n                gameOver: true,\r\n                youWin: false,\r\n                actionsToSend: actionsToSend\r\n                }\r\n            }\r\n\r\n          } else {\r\n            // Повторное попадание. Ход считаем, что не переходит\r\n            //actionsToSend.push({id:'0', Action: { action: { action_id: 'fireAgain', parameters: { coord: action.coord_str} } }});\r\n          }\r\n        } else {\r\n          actionsToSend.push({id:'0', Action: { action: { action_id: 'enemy_fire_miss', parameters: { coord: action.coord_str} } }});\r\n          // Попали в воду\r\n          let grid=state.my_board.grid.slice();\r\n          grid[y]=state.my_board.grid[y].slice();\r\n          if (grid[y][x] === Constants.GRID_VALUE_WATER)\r\n          {\r\n            // До этого туда не стреляли\r\n            fire_registered=true;\r\n            // хотя это бы и не обязательно делать (заполнять enemyField для воды), все равно попадание у нас контролируется по-другому,\r\n            // но для корректности данных лучше так сделать\r\n            let newMyField=state.myField.slice();\r\n            newMyField[y]=newMyField[y].slice();\r\n            newMyField[y][x]={...newMyField[y][x], shot:true};\r\n            //\r\n            grid[y][x] = Constants.GRID_VALUE_WATER_HIT;\r\n            //this.setState({ enemyField: newEnemyField, opponent_board: { ...this.state.opponent_board, grid: grid} });\r\n            return {...state,\r\n              my_board: { ...state.my_board, grid: grid}, myField: newMyField,\r\n              enemyTurn: false,\r\n              actionsToSend: actionsToSend\r\n            }\r\n          }\r\n        }\r\n      }\r\n  \r\n      return {\r\n        ...state,\r\n        actionsToSend: actionsToSend\r\n      }\r\n    }\r\n\r\n    case \"lets_fire\":\r\n    {\r\n      let actionsToSend=state.actionsToSend.slice();\r\n      if (state.enemyTurn)\r\n      {\r\n        // тут про сессии можно почитать\r\n        // https://developer.sberdevices.ru/docs/ru/developer_tools/ide/JS_API/session_lifetime_control\r\n        actionsToSend.push({id:'0', Action: { action: { action_id: 'myMove'} }});\r\n        // и на всякий случай защита от зависания таймера\r\n        return {\r\n          ...state,\r\n          actionsToSend: actionsToSend,\r\n          enemyTurnForce: state.enemyTurnForce+1\r\n        }\r\n        \r\n      } else\r\n      {\r\n        //alert(myAction.coord_str);\r\n        let fire_registered=false;\r\n        let coord=decodeCoordinate(action.coord_str);\r\n        if (coord)\r\n        {\r\n          let x=coord.x, y=coord.y;\r\n  \r\n          let field=state.enemyField[y][x];\r\n          if (field.containsShip)\r\n          {\r\n            // Попали в корабль\r\n            if (!field.shot)\r\n            {\r\n              // До этого в это поле не попадали\r\n              fire_registered=true;\r\n              let newEnemyField=state.enemyField.slice();\r\n              newEnemyField[y]=newEnemyField[y].slice();\r\n              newEnemyField[y][x]={...newEnemyField[y][x], shot:true};\r\n              let shipId=field.shipId;\r\n              // Проверим, есть ли еще не подбитые его части\r\n              let live_parts=0;\r\n              for (let y = 0; y < 10; y++) {\r\n                for (let x = 0; x < 10; x++) {\r\n                  if (newEnemyField[y][x].containsShip && newEnemyField[y][x].shipId===shipId)\r\n                  {\r\n                    if (!newEnemyField[y][x].shot)\r\n                      live_parts++;\r\n                  }\r\n                }\r\n              }\r\n              // TODO если корабль полностью подбит, рисовать его как-то по-другому\r\n          \r\n              let grid=state.opponent_board.grid.slice();\r\n              grid[y]=state.opponent_board.grid[y].slice();\r\n              grid[y][x] = Constants.GRID_VALUE_SHIP_HIT;\r\n              if (live_parts>0)\r\n                actionsToSend.push({id:'0', Action: { action: { action_id: 'fireHit', parameters: { coord: action.coord_str} } }});\r\n              else\r\n                actionsToSend.push({id:'0', Action: { action: { action_id: 'fireDone', parameters: { coord: action.coord_str} } }});\r\n              if (state.opponent_board.remaining_hit_points<=1)\r\n              {\r\n                actionsToSend.push({id:'0', Action: { action: { action_id: 'gameOverWin', parameters: {} } }});\r\n                // игрок выиграл\r\n                return {...state,\r\n                  opponent_board: {grid: grid, remaining_hit_points: state.opponent_board.remaining_hit_points-1},\r\n                  enemyField: newEnemyField,\r\n                  gameOver: true,\r\n                  youWin: true,\r\n                  actionsToSend: actionsToSend\r\n                  }\r\n              } else {\r\n                // просто очередное попадание, ход не переходит\r\n                return {...state,\r\n                opponent_board: {grid: grid, remaining_hit_points: state.opponent_board.remaining_hit_points-1},\r\n                enemyField: newEnemyField,\r\n                actionsToSend: actionsToSend,\r\n                debugLastUserTalkCoord: action.coord_str                \r\n                }\r\n              }\r\n  \r\n            } else {\r\n              // Повторное попадание. Ход считаем, что не переходит\r\n              actionsToSend.push({id:'0', Action: { action: { action_id: 'fireAgain', parameters: { coord: action.coord_str} } }});\r\n            }\r\n          } else {\r\n            // Попали в воду\r\n            let grid=state.opponent_board.grid.slice();\r\n            grid[y]=state.opponent_board.grid[y].slice();\r\n            if (grid[y][x] === Constants.GRID_VALUE_WATER)\r\n            {\r\n              // До этого туда не стреляли\r\n              fire_registered=true;\r\n              // хотя это бы и не обязательно делать (заполнять enemyField для воды), все равно попадание у нас контролируется по-другому,\r\n              // но для корректности данных лучше так сделать\r\n              let newEnemyField=state.enemyField.slice();\r\n              newEnemyField[y]=newEnemyField[y].slice();\r\n              newEnemyField[y][x]={...newEnemyField[y][x], shot:true};\r\n              //\r\n              grid[y][x] = Constants.GRID_VALUE_WATER_HIT;\r\n              //this.setState({ enemyField: newEnemyField, opponent_board: { ...this.state.opponent_board, grid: grid} });\r\n              actionsToSend.push({id:'0', Action: { action: { action_id: 'fireMiss', parameters: { coord: action.coord_str} } }});\r\n\r\n              return {...state,\r\n                actionsToSend: actionsToSend,\r\n                debugLastUserTalkCoord: action.coord_str,\r\n                opponent_board: { ...state.opponent_board, grid: grid}, enemyField: newEnemyField,\r\n                enemyTurn: true\r\n              }\r\n            } else actionsToSend.push({id:'0', Action: { action: { action_id: 'fireAgain', parameters: { coord: action.coord_str} } }});\r\n          }\r\n        }\r\n      }\r\n      return {\r\n        ...state,\r\n        actionsToSend: actionsToSend,\r\n        debugLastUserTalkCoord: action.coord_str\r\n      }\r\n    }\r\n      \r\n  \r\n\r\n      /*\r\n      let fire_registered=false;\r\n      let coord=decodeCoordinate(action.coord_str);\r\n      if (coord)\r\n      {\r\n        let x=coord.x, y=coord.y;\r\n\r\n        let field=state.enemyField[y][x];\r\n        if (field.containsShip)\r\n        {\r\n          // Попали в корабль\r\n          if (!field.shot)\r\n          {\r\n            // До этого в это поле не попадали\r\n            fire_registered=true;\r\n            let newEnemyField=state.enemyField.slice();\r\n            newEnemyField[y][x].shot=true;\r\n            let shipId=field.shipId;\r\n            // Проверим, есть ли еще не подбитые его части\r\n            let live_parts=0;\r\n            for (let y = 0; y < 10; y++) {\r\n              for (let x = 0; x < 10; x++) {\r\n                if (newEnemyField[y][x].containsShip && newEnemyField[y][x].shipId===shipId)\r\n                {\r\n                  if (!newEnemyField[y][x].shot)\r\n                    live_parts++;\r\n                }\r\n              }\r\n            }\r\n            // TODO если корабль полностью подбит, рисовать его как-то по-другому\r\n        \r\n            let grid=state.opponent_board.grid.slice();\r\n            grid[y][x] = Constants.GRID_VALUE_SHIP_HIT;\r\n            //setState({ enemyField: newEnemyField, opponent_board: { ...appState.opponent_board, grid: grid, remaining_hit_points: remaining_hit_points} });\r\n            let newState={...state,\r\n            opponent_board: {grid: grid, remaining_hit_points: state.opponent_board.remaining_hit_points-1},\r\n            enemyField: newEnemyField\r\n            };\r\n            return newState;\r\n          } else {\r\n            // Повторное попадание\r\n          }\r\n        } else {\r\n          // Попали в воду\r\n          let grid=state.opponent_board.grid.slice();\r\n          if (grid[y][x] === Constants.GRID_VALUE_WATER)\r\n          {\r\n            // До этого туда не стреляли\r\n            fire_registered=true;\r\n            // хотя это бы и не обязательно делать (заполнять enemyField для воды), все равно попадание у нас контролируется по-другому,\r\n            // но для корректности данных лучше так сделать\r\n            let newEnemyField=state.enemyField.slice();\r\n            newEnemyField[y][x].shot=true;\r\n            //\r\n            grid[y][x] = Constants.GRID_VALUE_WATER_HIT;\r\n            //this.setState({ enemyField: newEnemyField, opponent_board: { ...this.state.opponent_board, grid: grid} });\r\n            return {\r\n              ...state,\r\n              opponent_board: { ...state.opponent_board, grid: grid}, enemyField: newEnemyField\r\n            };\r\n      \r\n          }\r\n        }\r\n      }\r\n      return {\r\n        ...state,     \r\n      }\r\n      */\r\n      \r\n/* \r\n      let grid=state.opponent_board.grid.slice();\r\n      grid[0][0] = Constants.GRID_VALUE_SHIP_HIT;\r\n      let remaining_hit_points = state.opponent_board.remaining_hit_points;\r\n      remaining_hit_points = remaining_hit_points - 1;\r\n      return {\r\n        ...state,\r\n        opponent_board: { grid: grid, remaining_hit_points: remaining_hit_points }\r\n      };\r\n     case \"add_note\":\r\n      return {\r\n        ...state,\r\n        notes: [\r\n          ...state.notes,\r\n          {\r\n            id: Math.random().toString(36).substring(7),\r\n            title: action.note,\r\n            completed: false,\r\n          },\r\n        ],\r\n      };\r\n\r\n    case \"done_note\":\r\n      return {\r\n        ...state,\r\n        notes: state.notes.map((note) =>\r\n          note.id === action.id ? { ...note, completed: !note.completed } : note\r\n        ),\r\n      };\r\n\r\n    case \"delete_note\":\r\n      return {\r\n        ...state,\r\n        notes: state.notes.filter(({ id }) => id !== action.id),\r\n      };\r\n      */\r\n\r\n    default:\r\n      throw new Error();\r\n  }\r\n};\r\n","import React, {\r\n  FC,\r\n  memo,\r\n  useReducer,\r\n  useState,\r\n  useRef,\r\n  useEffect,\r\n  useLayoutEffect,\r\n  RefObject,\r\n} from 'react';\r\n\r\nimport {\r\n  createSmartappDebugger,\r\n  createAssistant,\r\n  createRecordPlayer,\r\n  AssistantAppState,\r\n  AssistantSmartAppData,\r\n  AssistantCharacterType\r\n} from \"@sberdevices/assistant-client\";\r\n\r\n//import  {Link} from 'react-router-dom';\r\n\r\nimport Constants from './constants';\r\nimport Header from './components/header'\r\nimport Chat from './components/chat'\r\nimport MyBoard from './components/my_board'\r\nimport OpponentBoard from './components/opponent_board';\r\n\r\nimport placeShip from './utils/placeShip';\r\nimport placeVarious from './utils/standardShipsSet';\r\n\r\n\r\n// Это не обязательно, т.к. все в в index на самом деле\r\n//import './App.css';\r\n\r\nimport { getRandomInt, codeCoordinate, codeCoordinateNames, decodeCoordinate} from './utils/Common';\r\nimport { initialState, reducer } from \"./store\";\r\n\r\n// createGlobalStyle нужен для создания глобальных стилей\r\nimport styled, { createGlobalStyle, css } from 'styled-components';\r\n\r\n// получаем значение для целевой платформы\r\nimport { sberBox } from '@sberdevices/plasma-tokens/typo';\r\n// получаем стилевые объекты для нашего интерфейса\r\nimport { body1, headline2 } from '@sberdevices/plasma-tokens';\r\n\r\n// получаем тему персонажа\r\nimport { darkEva, darkSber, darkJoy } from '@sberdevices/plasma-tokens/themes';\r\n\r\n// получаем цвета для нашего интерфейса\r\nimport { text, background, gradient } from '@sberdevices/plasma-tokens';\r\n\r\nimport { Button } from '@sberdevices/ui';\r\nimport { createArrayTypeNode } from 'typescript';\r\n\r\n//import { IconDownload } from '@sberdevices/plasma-icons';\r\n\r\n\r\n\r\nconst AppStyled = styled.div`\r\n    padding: 30px;\r\n    ${body1}\r\n`;\r\n\r\n// создаем react-компонент c глобальными стилями типографики\r\nconst TypoScale = createGlobalStyle(sberBox);\r\n\r\n// создаем react-компонент для подложки\r\nconst DocStyles = createGlobalStyle`\r\n    /* stylelint-disable-next-line selector-nested-pattern */\r\n    html {\r\n        color: ${text};\r\n        background-color: ${background};\r\n        background-image: ${gradient};\r\n\r\n        /** необходимо залить градиентом всю подложку */\r\n        min-height: 100vh;\r\n    }\r\n`;\r\n// создаем react-компонент для персонажа\r\n//const Theme = createGlobalStyle(darkJoy);\r\n//const Theme = createGlobalStyle(lightJoy);\r\n\r\nconst ThemeBackgroundEva = createGlobalStyle(darkEva);\r\nconst ThemeBackgroundSber = createGlobalStyle(darkSber);\r\nconst ThemeBackgroundJoy = createGlobalStyle(darkJoy);\r\n\r\n// Плазма\r\n//https://plasma.sberdevices.ru/current/?path=/docs/about--page\r\n\r\n\r\nconst initializeAssistant = (getState: any) => {\r\n  console.log('process.env.NODE_ENV=');\r\n  console.log(process.env.NODE_ENV);\r\n  if (process.env.NODE_ENV === \"development\") {\r\n    return createSmartappDebugger({\r\n      token: process.env.REACT_APP_TOKEN ?? \"\",\r\n      initPhrase: `Запусти ${process.env.REACT_APP_SMARTAPP}`,\r\n      getState,\r\n    });\r\n  }\r\n\r\n  return createAssistant({ getState });\r\n};\r\n\r\n\r\nexport const App: FC = memo(() => {\r\n  const [appState, dispatch] = useReducer(reducer, initialState);\r\n  //const [note, setNote] = useState(\"\");\r\n  //const [appState, setAppState] = useState(constFullInitialState);\r\n\r\n  const assistantStateRef = useRef<AssistantAppState>();\r\n  const assistantRef = useRef<ReturnType<typeof createAssistant>>();\r\n\r\n  useEffect(() => {\r\n\r\n    dispatch({type: 'init'});\r\n\r\n    assistantRef.current = initializeAssistant(() => assistantStateRef.current);\r\n\r\n    //assistantRef.current.on(\"start\", () => {\r\n    //  alert(\"Start!\");\r\n    //});\r\n\r\n    assistantRef.current.on(\"data\", ({ type, character, navigation, action, insets }: any) => {\r\n      // Из-за того, что React.Strict несмотря на то, что вызов я делаю 1 раз, dispatch срабатывае дважды\r\n      // поэтому сделаем счетчик\r\n      // AssistantCharacterCommand\r\n      if (character)\r\n      {\r\n        // TODO брать respectfulAppeal из character\r\n        // 'sber' | 'eva' | 'joy';\r\n        //setAppState({...appState, character: character.id, respectfulAppeal: character.id!=='joy'});\r\n        dispatch({type: 'character', character_id: character.id});\r\n      }\r\n      // AssistantServerAction\r\n      if (action) {\r\n        dispatch(action);\r\n      }\r\n      // AssistantInsetsCommand - команда, которая сообщает смартапу о том, что поверх него будет отображен нативный UI и его размеры.\r\n      if (insets)\r\n      {\r\n        //alert(\"left=\"+insets.left+\", top=\"+insets.top+\", right=\"+insets.right+\", bottom=\"+insets.bottom);\r\n      }\r\n    });\r\n\r\n\r\n\r\n  }, []);\r\n\r\n  useEffect(() => {\r\n    assistantStateRef.current = {\r\n      gameOver: appState.gameOver\r\n      /*\r\n      item_selector: {\r\n        items: appState.notes.map(({ id, title }, index) => ({\r\n          number: index + 1,\r\n          id,\r\n          title,\r\n        })),\r\n      },\r\n        */\r\n    };\r\n  }, [appState.gameOver]);\r\n\r\n  useEffect(() => {\r\n    //assistantRef.current?.sendData({ action: { action_id: 'myMove'} });\r\n\r\n    if (appState.actionsToSend.length>0)\r\n    {\r\n      appState.actionsToSend.forEach(element => {\r\n        assistantRef.current?.sendData(element.Action);\r\n\r\n        //alert('Сообщение');\r\n\r\n        /*\r\n        const unsubscribe = assistantRef.current?.sendAction(\r\n          { type: 'some_action_name', payload: { param: 'some' } },\r\n          (data: { type: string; payload: Record<string, unknown> }) => {\r\n              // здесь обработка данных, переданных от бэкенд\r\n              if (unsubscribe)\r\n                unsubscribe();\r\n          },\r\n          (error: { code: number; description: string }) => {\r\n              // обработка ошибки, переданной от бэкенд\r\n          });        \r\n        */\r\n       /*\r\n        const unsubscribe = assistantRef.current?.sendAction(\r\n          element.Action.action,\r\n          (data: { type: string; payload: Record<string, unknown> }) => {\r\n            //if (data.type === 'smart_app_data' && data.smart_app_data?.type === 'lets_fire') {\r\n              // здесь обработка данных, переданных от бэкенд\r\n              alert(\"res1\");\r\n              if (unsubscribe)\r\n                unsubscribe();\r\n          },\r\n          (error: { code: number; description: string }) => {\r\n              // обработка ошибки, переданной от бэкенд\r\n              alert(\"error!\");\r\n          });\r\n          */\r\n\r\n      });\r\n      dispatch({type: 'clear_action', id: '0'});\r\n    }\r\n  }, [appState.actionsToSend]);\r\n\r\n  useEffect(() => {\r\n    if (appState.enemyTurn)\r\n    {\r\n      // TODO тест передаем ход игроку\r\n      //setAppState({...appState, enemyTurn: false});\r\n      // Чтобы успел сказать предыдущую фразу, бот делает ход раз в 3 секунды\r\n      setTimeout(() => processEnemyMove(), 3100);\r\n    }\r\n  }, [appState.enemyTurn, appState.enemyTurnForce]);\r\n\r\n\r\n\r\n\r\n/*\r\n  // { type: \"lets_fire\", coord_str: codeCoordinate(x,y)})\r\n  function myDispatch(myAction: any)\r\n  {\r\n\r\n    if (myAction.type==='show_ships')\r\n    {\r\n      setAppState({...appState, showHidden: true});\r\n    }\r\n\r\n    if (myAction.type==='game_over_lost')\r\n    {\r\n      setAppState({...appState, gameOver: true, youWin: false\r\n      });\r\n    }\r\n\r\n    if (myAction.type==='game_replay')\r\n    {\r\n      // тот же код, что при иннициализации\r\n      // кроме установки персонажа\r\n      let newAppState=getFullInitialState();\r\n      newAppState.character=appState.character;\r\n      newAppState.respectfulAppeal=appState.respectfulAppeal;\r\n      setAppState(newAppState);\r\n    }\r\n\r\n\r\n    if (myAction.type==='lets_fire')\r\n    if (appState.enemyTurn)\r\n    {\r\n      // тут про сессии можно почитать\r\n      // https://developer.sberdevices.ru/docs/ru/developer_tools/ide/JS_API/session_lifetime_control\r\n      assistantRef.current?.sendData({ action: { action_id: 'myMove'} });\r\n    } else\r\n    {\r\n      //alert(myAction.coord_str);\r\n      let fire_registered=false;\r\n      let coord=decodeCoordinate(myAction.coord_str);\r\n      if (coord)\r\n      {\r\n        let x=coord.x, y=coord.y;\r\n\r\n        let field=appState.enemyField[y][x];\r\n        if (field.containsShip)\r\n        {\r\n          // Попали в корабль\r\n          if (!field.shot)\r\n          {\r\n            // До этого в это поле не попадали\r\n            fire_registered=true;\r\n            let newEnemyField=appState.enemyField.slice();\r\n            newEnemyField[y][x].shot=true;\r\n            let shipId=field.shipId;\r\n            // Проверим, есть ли еще не подбитые его части\r\n            let live_parts=0;\r\n            for (let y = 0; y < 10; y++) {\r\n              for (let x = 0; x < 10; x++) {\r\n                if (newEnemyField[y][x].containsShip && newEnemyField[y][x].shipId===shipId)\r\n                {\r\n                  if (!newEnemyField[y][x].shot)\r\n                    live_parts++;\r\n                }\r\n              }\r\n            }\r\n            // TODO если корабль полностью подбит, рисовать его как-то по-другому\r\n        \r\n            let grid=appState.opponent_board.grid.slice();\r\n            grid[y][x] = Constants.GRID_VALUE_SHIP_HIT;\r\n            //setState({ enemyField: newEnemyField, opponent_board: { ...appState.opponent_board, grid: grid, remaining_hit_points: remaining_hit_points} });\r\n            if (live_parts>0)\r\n              assistantRef.current?.sendData({ action: { action_id: 'fireHit', parameters: { coord: myAction.coord_str} } });\r\n            else\r\n            assistantRef.current?.sendData({ action: { action_id: 'fireDone', parameters: { coord: myAction.coord_str} } });\r\n            if (appState.opponent_board.remaining_hit_points<=1)\r\n            {\r\n              // игрок выиграл\r\n              setAppState({...appState,\r\n                opponent_board: {grid: grid, remaining_hit_points: appState.opponent_board.remaining_hit_points-1},\r\n                enemyField: newEnemyField,\r\n                gameOver: true,\r\n                youWin: true\r\n                });\r\n                assistantRef.current?.sendData({ action: { action_id: 'gameOverWin', parameters: {} } });\r\n            } else {\r\n              // просто очередное попадание, ход не переходит\r\n              setAppState({...appState,\r\n              opponent_board: {grid: grid, remaining_hit_points: appState.opponent_board.remaining_hit_points-1},\r\n              enemyField: newEnemyField\r\n              });\r\n            }\r\n\r\n          } else {\r\n            // Повторное попадание. Ход считаем, что не переходит\r\n            assistantRef.current?.sendData({ action: { action_id: 'fireAgain', parameters: { coord: myAction.coord_str} } });\r\n          }\r\n        } else {\r\n          // Попали в воду\r\n          let grid=appState.opponent_board.grid.slice();\r\n          if (grid[y][x] === Constants.GRID_VALUE_WATER)\r\n          {\r\n            // До этого туда не стреляли\r\n            fire_registered=true;\r\n            // хотя это бы и не обязательно делать (заполнять enemyField для воды), все равно попадание у нас контролируется по-другому,\r\n            // но для корректности данных лучше так сделать\r\n            let newEnemyField=appState.enemyField.slice();\r\n            newEnemyField[y][x].shot=true;\r\n            //\r\n            grid[y][x] = Constants.GRID_VALUE_WATER_HIT;\r\n            //this.setState({ enemyField: newEnemyField, opponent_board: { ...this.state.opponent_board, grid: grid} });\r\n            setAppState({...appState,\r\n              opponent_board: { ...appState.opponent_board, grid: grid}, enemyField: newEnemyField,\r\n              enemyTurn: true\r\n            });\r\n          }\r\n          assistantRef.current?.sendData({ action: { action_id: 'fireMiss', parameters: { coord: myAction.coord_str} } });\r\n        }\r\n      }\r\n\r\n      // Теперь он сам стреляет\r\n      // (сделано специально, чтобы в любом случае произошла проверка, чтобы игровой процесс не остановился по какой-нибудь причине)\r\n      //setTimeout(() => processEnemyMove(), 3100);\r\n\r\n    }\r\n  }\r\n\r\n  // вернет true, если оппонент попал\r\n  // в этом случае ход не переходит\r\n  function fireMyBoard(alphabetical_coord: string)\r\n  {\r\n    const coordinate=decodeCoordinate(alphabetical_coord);\r\n    if (coordinate==null)\r\n      return false;\r\n    const x=coordinate.x;\r\n    const y=coordinate.y;\r\n\r\n    let fire_registered=false;\r\n\r\n    let field=appState.myField[y][x];\r\n    if (field.containsShip)\r\n    {\r\n      // Попали в корабль\r\n      if (!field.shot)\r\n      {\r\n        // До этого в это поле не попадали\r\n        fire_registered=true;\r\n        let newEnemyField=appState.myField.slice();\r\n        newEnemyField[y][x].shot=true;\r\n        let shipId=field.shipId;\r\n        // Проверим, есть ли еще не подбитые его части\r\n        let live_parts=0;\r\n        for (let y = 0; y < 10; y++) {\r\n          for (let x = 0; x < 10; x++) {\r\n            if (newEnemyField[y][x].containsShip && newEnemyField[y][x].shipId===shipId)\r\n            {\r\n              if (!newEnemyField[y][x].shot)\r\n                live_parts++;\r\n            }\r\n          }\r\n        }\r\n        // TODO если корабль полностью подбит, рисовать его как-то по-другому\r\n    \r\n        let grid=appState.my_board.grid.slice();\r\n        grid[y][x] = Constants.GRID_VALUE_SHIP_HIT;\r\n        setAppState({...appState, myField: newEnemyField, my_board: { ...appState.my_board, grid: grid} });\r\n        return true;\r\n      } else {\r\n        // Повторное попадание\r\n      }\r\n    } else {\r\n      // Попали в воду\r\n      let grid=appState.my_board.grid.slice();\r\n      if (grid[y][x] === Constants.GRID_VALUE_WATER)\r\n      {\r\n        // До этого туда не стреляли\r\n        fire_registered=true;\r\n        let newEnemyField=appState.myField.slice();\r\n        newEnemyField[y][x].shot=true;\r\n        grid[y][x] = Constants.GRID_VALUE_WATER_HIT;\r\n        setAppState({...appState, myField: newEnemyField, my_board: { ...appState.my_board, grid: grid} });\r\n      }\r\n    }\r\n    return false;\r\n\r\n  }\r\n  */\r\n\r\n  function processEnemyMove()\r\n  {\r\n    // только в свой ход\r\n    if (!appState.enemyTurn)\r\n      return;\r\n\r\n    const offsets=[{x:-1,y:-1}, {x:0,y:-1}, {x:1,y:-1},\r\n      {x:-1,y:0}, {x:0,y:0}, {x:1,y:0},\r\n      {x:-1,y:1}, {x:0,y:1}, {x:1,y:1},\r\n    ];\r\n\r\n    const offsets4=[{x:0,y:-1},{x:-1,y:0},{x:1,y:0},{x:0,y:1}];\r\n\r\n    let field=appState.myField;\r\n    // Первый проход, ищем точки, где рядом есть с попаданиями\r\n    // они будут иметь признак первичных\r\n    // а уже на втором проходе будет происходить поиск, куда можно в принципе выстрелить\r\n    // поэтому если координата будет иметь признак первичной, но стрелять туда нельзя, она в массив не попадет\r\n    let primary_area=Array.from(Array(10), _ => Array(10).fill(0));\r\n    // если в этой координате подбитый корабль\r\n    // найдем, есть ли не подбитые в 4-х направлениях от него\r\n    // и если есть, то это он сам (т.к. нельзя ставить рядом)\r\n    // Заодно заполним список живых кораблей\r\n    let live_ships=new Set();\r\n    for (let y = 0; y < 10; y++) {\r\n      for (let x = 0; x < 10; x++) {\r\n        for (let i=0; i<offsets4.length; i++){\r\n          if (field[y][x].containsShip&&!field[y][x].shot) {\r\n            live_ships.add(field[y][x].shipId);\r\n          }\r\n          let _x=x+offsets4[i].x;\r\n          let _y=y+offsets4[i].y;\r\n          if (_x>=0&&_x<10&&_y>=0&&_y<10&&field[_y][_x].containsShip&&field[_y][_x].shot)\r\n          {\r\n            primary_area[y][x]=1;\r\n            break;\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    let primary_targets=[];\r\n    let targets=[];\r\n\r\n    // составим массив координат, куда враг может выстрелить\r\n    for (let y = 0; y < 10; y++) {\r\n      for (let x = 0; x < 10; x++) {\r\n        // если туда еще не стреляли\r\n        let canFire=true;\r\n        if (!field[y][x].shot)\r\n        {\r\n          // и вблизи нет подбитых (полностью) кораблей\r\n          for (let i=0; i<offsets.length; i++){\r\n            let _x=x+offsets[i].x;\r\n            let _y=y+offsets[i].y;\r\n            if (_x>=0&&_x<10&&_y>=0&&_y<10&&field[_y][_x].containsShip&&field[_y][_x].shot)\r\n            {\r\n              if (!live_ships.has(field[_y][_x].shipId))\r\n              {\r\n                canFire=false;\r\n                break;\r\n              }\r\n            }\r\n          }\r\n          if (canFire)\r\n          {\r\n            targets.push({y:y, x:x});\r\n            if (primary_area[y][x]===1)\r\n              primary_targets.push({y:y, x:x});\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    // На всякий случай проверка, что есть куда выстрелить (по идее в этом случае игра уже закончена)\r\n    if (targets.length>0)\r\n    {\r\n      // Координаты выстрела\r\n      let fire_coord=primary_targets.length>0?primary_targets[getRandomInt(0, primary_targets.length-1)]:targets[getRandomInt(0, targets.length-1)];\r\n      // Фикс от 09.04.2021, учитывающий, что корабли стоят в одну линию\r\n      // TODO должен знать максимальную возможную длину оставшихся кораблей\r\n      let max_len=4;\r\n      let mega_primary: { y: number; x: number; }[]=[];\r\n      primary_targets.forEach(element => {\r\n        for (let dir=0; dir<2; dir++)\r\n        {\r\n          // это смещение влево (dir=0) или вверх (dir=1)\r\n          for (let i=-max_len+1; i<max_len; i++)\r\n          {\r\n            let count=0;\r\n            let shipId=0;\r\n            // это индекс элемента\r\n            for (let j=0; j<max_len; j++)\r\n            {\r\n              let x=element.x;\r\n              let y=element.y;\r\n              if (dir===0)\r\n              {\r\n                x+=i+j;\r\n              } else\r\n              {\r\n                y+=i+j;\r\n              }\r\n              // первый элемент должен быть подбитым кораблем\r\n              if (j==0)\r\n              {\r\n                // в пределах поля\r\n                if (x>=0&&x<=9&&y>=0&&y<=9)\r\n                {              \r\n                  let myField=appState.myField[y][x];\r\n                  if (myField.shot&&myField.containsShip)\r\n                    shipId=myField.shipId;\r\n                  else\r\n                    break;\r\n                }\r\n                else\r\n                  break;\r\n              }\r\n              // в пределах поля\r\n              if (x>=0&&x<=9&&y>=0&&y<=9)\r\n              {\r\n                let myField=appState.myField[y][x];\r\n                // и корабль тот же (хотя это не совсем честно, но человек бы смог бы так же догадаться, что корабли разные\r\n                // зная, что один из них подбит, например\r\n                if (myField.shot&&myField.containsShip&&shipId===myField.shipId)\r\n                  count++;\r\n              }\r\n            }\r\n            if (count>=2)\r\n            {\r\n              mega_primary.push({x:element.x, y:element.y});\r\n              // Один раз добавим эту координату и все\r\n              // (но может добавиться и по двум направлениям, что просто увеличит вероятность выпадения\r\n              // этой координаты - не страшно)\r\n              break;\r\n            }\r\n\r\n          }\r\n        }\r\n      });\r\n\r\n      if (mega_primary.length>0)\r\n      {\r\n        fire_coord=mega_primary[getRandomInt(0, mega_primary.length-1)];\r\n      }\r\n      //\r\n\r\n      let alphabetical_coord=codeCoordinateNames(fire_coord.x, fire_coord.y);\r\n\r\n\r\n      /*\r\n      if (fireMyBoard(alphabetical_coord))\r\n      {\r\n        // если попал, проверяем, победа это или запускаем следующий ход оппонента\r\n        let playerLivesCount=0;\r\n        for (let y = 0; y < 10; y++) {\r\n          for (let x = 0; x < 10; x++) {\r\n            // если туда еще не стреляли\r\n            if (!field[y][x].shot&&field[y][x].containsShip)\r\n              playerLivesCount++;\r\n          }\r\n        }\r\n        //if (playerLivesCount>0)\r\n        //  setTimeout(() => processEnemyMove(), 3100);\r\n        //else\r\n        if (playerLivesCount<=0)\r\n        {\r\n          //setAppState({...appState, gameOver: true, youWin: false});\r\n          assistantRef.current?.sendData({ action: { action_id: 'gameOverLost', parameters: {} } });\r\n        }\r\n        return;\r\n      }\r\n      */\r\n     dispatch({ type: \"enemy_fire\", coord_str: alphabetical_coord});\r\n    }\r\n    // В остальных случаях ход переходит к игроку\r\n    //setAppState({...appState, enemyTurn: false});\r\n  }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nfunction myByCode(s: string)\r\n{\r\n  let result=\"\";\r\n  for (let i=0; i<s.length; i++)\r\n  {\r\n    result=result+s.codePointAt(i)?.toString()+\",\";\r\n  }\r\n  return result;\r\n}\r\n\r\n\r\n  function _renderResult() {\r\n\r\n    //const { game, playerId, winnerId } = this.props;\r\n    const {youWin} = appState;\r\n  \r\n    const message = youWin ? 'Вы победили!' : 'Вы потерпели крушение, сухопутный!';\r\n  \r\n    //setDocumentTitle(`${message} · #${game.id}`);\r\n  \r\n    return (\r\n      <div id=\"game_result\">\r\n        <header>\r\n        {/*<Logo/>*/}\r\n          <h1>Игра окончена</h1>\r\n          <p>{message}</p>\r\n        </header>\r\n        {/*<Link to=\"/\">Back to home</Link>*/}\r\n      </div>\r\n    );\r\n  }\r\n  \r\n  function _renderOpponentBoard() {\r\n    //const { dispatch, game, gameChannel, playerId, currentTurn, readyForBattle } = this.props;\r\n  \r\n    /*\r\n    if (!readyForBattle) return (\r\n        <Instructions\r\n            readyForBattle={readyForBattle}\r\n            playerIsAttacker={playerId === game.attacker}/>\r\n    );\r\n     */\r\n  \r\n    //const opponentBoard = this.state.opponent_board_0;\r\n    // а вот через data к ним можно бы обратиться только внутри OpponentBoard\r\n    const remaining_hit_points = appState.opponent_board.remaining_hit_points;\r\n  \r\n    return (\r\n      <div id=\"opponents_board_container\">\r\n        <header><h2>Поле для стрельбы</h2></header>        \r\n        <OpponentBoard\r\n          //dispatch={dispatch}\r\n          //gameChannel={gameChannel}\r\n          data={appState.opponent_board}\r\n          showHidden={appState.showHidden}\r\n          //playerId={playerId}\r\n          //currentTurn={currentTurn}\r\n          //onClickBoard={() => dispatch({ type: \"add_note\", note: \"123\" })}\r\n          // TODO\r\n          onClickBoard={(x:any, y:any) => dispatch({ type: \"lets_fire\", coord_str: codeCoordinate(x,y)})}\r\n        />\r\n        <p>Попаданий до победы: {remaining_hit_points}{/*/{myByCode(appState.debugLastUserTalkCoord)}*/}</p>\r\n      </div>\r\n    );\r\n  \r\n  }\r\n  \r\n  \r\n  // 559x568, 768x400, 959x400, 1920x1080\r\n  function _renderGameContent() {\r\n    if (appState.gameOver) return _renderResult();\r\n  \r\n    return (\r\n      <section id=\"main_section\">\r\n        <section id=\"boards_container\">\r\n          <div id=\"my_board_container\">\r\n            <header><h2>Свои корабли</h2></header>\r\n            <MyBoard\r\n              //dispatch={dispatch}\r\n              //gameChannel={gameChannel}\r\n              //selectedShip={selectedShip}\r\n              data={appState.my_board}\r\n            />\r\n          </div>\r\n          {\r\n            _renderOpponentBoard()\r\n          }\r\n        </section>\r\n        {\r\n          <Header\r\n          //game={GameShowView}\r\n          //playerId={playerId}\r\n          enemyTurn={appState.enemyTurn}\r\n          respectfulAppeal={appState.respectfulAppeal}\r\n          >\r\n          </Header>\r\n        }\r\n      </section>\r\n    );\r\n  \r\n  }\r\n  \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n  return (\r\n    <AppStyled>\r\n    {/* Используем глобальные react-компоненты один раз */}\r\n    <TypoScale />\r\n    <DocStyles />\r\n    {(() => {\r\n                switch (appState.character) {\r\n                    case 'sber':\r\n                        return <ThemeBackgroundSber />;\r\n                    case 'eva':\r\n                        return <ThemeBackgroundEva />;\r\n                    case 'joy':\r\n                        return <ThemeBackgroundJoy />;\r\n                    default:\r\n                        return;\r\n                }\r\n            })()}    \r\n    {/*<Theme />*/}\r\n    {/*<Button onClick={() => doneNote(\"Test!\")}>Normal Button</Button>*/}\r\n    <main id=\"game_show\" className=\"view-container\">\r\n      {_renderGameContent()}\r\n      {/*\r\n      <form\r\n        onSubmit={(event) => {\r\n          event.preventDefault();\r\n          dispatch({ type: \"add_note\", note });\r\n          setNote(\"\");\r\n        }}\r\n      >\r\n        <input\r\n          className=\"add-note\"\r\n          type=\"text\"\r\n          placeholder=\"Add Note\"\r\n          value={note}\r\n          onChange={({ target: { value } }) => setNote(value)}\r\n          required\r\n          autoFocus\r\n        />\r\n      </form>\r\n      <ul className=\"notes\">\r\n        {appState.notes.map((note, index) => (\r\n          <li className=\"note\" key={note.id}>\r\n            <span>\r\n              <span style={{ fontWeight: \"bold\" }}>{index + 1}. </span>\r\n              <span\r\n                style={{\r\n                  textDecorationLine: note.completed ? \"line-through\" : \"none\",\r\n                }}\r\n              >\r\n                {note.title}\r\n              </span>\r\n            </span>\r\n            <input\r\n              className=\"done-note\"\r\n              type=\"checkbox\"\r\n              checked={note.completed}\r\n              onChange={() => dispatch({ type: \"done_note\", id: note.id })}\r\n            />\r\n          </li>\r\n        ))}\r\n      </ul>\r\n      */}\r\n    </main>\r\n    </AppStyled>\r\n  );\r\n});\r\n","import { ReportHandler } from 'web-vitals';\r\n\r\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\r\n  if (onPerfEntry && onPerfEntry instanceof Function) {\r\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\r\n      getCLS(onPerfEntry);\r\n      getFID(onPerfEntry);\r\n      getFCP(onPerfEntry);\r\n      getLCP(onPerfEntry);\r\n      getTTFB(onPerfEntry);\r\n    });\r\n  }\r\n};\r\n\r\nexport default reportWebVitals;\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport {App} from './App';\r\nimport reportWebVitals from './reportWebVitals';\r\n\r\nReactDOM.render(\r\n  <React.StrictMode>\r\n    <App />\r\n  </React.StrictMode>,\r\n  document.getElementById('root')\r\n);\r\n\r\n// If you want to start measuring performance in your app, pass a function\r\n// to log results (for example: reportWebVitals(console.log))\r\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\r\nreportWebVitals();\r\n"],"sourceRoot":""}